/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() { return "02.04.00" }

/**
 * Motion based thermostat
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 *
 * Change log:
 * 2020-07-31 - (v02.04.00) New app/platform improvements
 * 2020-06-17 - (v02.03.12) Fix for fan modes being continually set
 * 2020-05-04 - (v02.03.11) Try to detect platform outage and prevent code upgrade spam notifications
 * 2020-02-05 - (v02.03.10) Add limits for temperature inputs
 * 2020-01-20 - (v02.03.09) Update icons for broken ST Android app 2.18
 * 2019-12-12 - (v02.03.08) Add swing temp range
 * 2019-07-25 - (v02.03.07) Update thermostat setpoint for remote temperature sensors to be compatible with trane thermostat limits
 * 2019-02-04 - (v02.03.06) Improvement to safety turn off when remote sensor temperature change is detected
 * 2019-01-10 - (v02.03.05) Check motion sensor state at start of schedule, fix for DST adjustments not made by platform automatically
 * 2018-12-21 - (v02.03.04) Update max/min cooling/heating setpoints to be compatible with the Pearl Centralite thermostat
 * 2018-08-06 - (v02.03.02) Added option to save battery by reducing communications, disable if thermostat has losing commands in the mesh
 * 2017-09-09 - (v02.03.01) Updated min temp to 60F for better GoControl thermostat compatibility
 * 2017-09-05 - (v02.03.00) Updated min/max thresholds for remote sensors to be compatible with new ST thermostat device handler (deadZones), fixed support for end time > start time
 * 2017-09-03 - (v02.02.01) Improve safety of operating schedule idle, at end of operating time force a single Idle and don't set idle after operating hours when motion stops
 * 2017-09-02 - (v02.02.00) Don't set IDLE temperatues if outside the configured operating schedule, but retain safety turn off one time outside schedule
 * 2017-01-28 - (v02.01.01) Added support for multiple remote temperature sensors (average across them)
 * 2016-11-05 - Added support for automatic code update notifications and fixed an issue with sms
 * 2016-10-09 - Tweak the threshold setting to help compensate for sensors which update with lower accuracy
 * 2016-09-09 - Fixed UI inconsistencies, motion sensors are no optional and use of dynamic pages
 * 2016-08-09 - Added support for remote temperature sensor
 * 2016-07-29 - Thermostat is optional to allow to temporary disabling of SmartApp
 * 2016-07-07 - Day of week is mandatory
 * 2016-05-19 - If end time is after start time then assume the end time is next day
 * 2016-05-15 - Notify use if timezone/location is missing in setup 
 * 2016-03-21 - Set new temperature immediately after settings are updated
 * 2016-02-08 - Check current setting before setting temperature on thermostat to save thermostat battery
 * 2016-01-23 - Fix for multiple motion sensors, now idle will be turned on if ALL motion sensors are reporting inactive
 * 2015-06-17 - Fix for changes in ST platform
 * 2015-02-11 -> Bug fix for fan mode
 * 2015-01-01 -> Added support for multiple sensor selection and default value for timeout
 * 2014-11-24 -> Added support for timeout configuration if there is no motion
*/
definition(
    name: "Motion based thermostat",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Motion sensor based thermostat settings. This thermostat has 2 states, with someone in the room (motion) and room empty (no motion). You can schedule it to work during specific times and during specifics days of the week",
    category: "Green Living",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@2x.png",
    iconX3Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@3x.png")

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
}

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "Motion Based Thermostat v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Motion Based Thermostat v${clientVersion()}", install: true, uninstall: true) {
        section("Choose thermostat ") {
            input "thermostat", "capability.thermostat", required: false
        }

        section("Choose Motion Sensor(s)") {
            input "motionSensor", "capability.motionSensor", multiple: true, required: false
        }

        section("Use remote temperature sensor to control thermostat (optional)", hidden: (remoteTemperatureSensor ? false : true), hideable: true) {
            if ((remoteTemperatureSensor*.currentTemperature)?.count { it } > 1) {
                paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
            }
            input "remoteTemperatureSensor", "capability.temperatureMeasurement", title: "Remote sensor", required: false, multiple:true, submitOnChange: true
            if (remoteTemperatureSensor) {
                input "threshold", "decimal", title: "Temperature swing (precision)", defaultValue: "1.0", required: true, range: "0.4..5.0" // TODO: watch range, causes Android 2.0.7 to crash
            }
        }

        section("Set operating mode temperatures") {
            input "opHeatSet", "decimal", title: "When Heating", range: "0..100", description: "Heating temperature when motion is detected"
            input "opCoolSet", "decimal", title: "When Cooling", range: "0..100", description: "Cooling temperature when motion is detected"
        }

        section("Set idle mode temperatures") {
            input "idHeatSet", "decimal", title: "When Heating", range: "0..100", description: "Heating temperature when idle is detected"
            input "idCoolSet", "decimal", title: "When Cooling", range: "0..100", description: "Cooling temperature when idle is detected"
        }

        section("Set delay while switching from operating to idle mode (no motion detected)") {
            input "idleTimeout", "number", title: "Time in Minutes (0 for immediate)", defaultValue: 15
        }

        section("Select the operating mode time and days (optional)") {
            input "startTime", "time", title: "Start Time", required: false
            input "endTime", "time", title: "End Time", required: false
            input "dayOfWeek", "enum",
                title: "Which day of the week?",
                required: true,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ],
                defaultValue: 'All Week'
        }

        section("Thermostat Operating Modes (optional)") {
            mode title: "Enable thermostat only when in this mode(s)", required: false, multiple: true
        }

        section("Switch HVAC mode (auto to cool/heat) based on the outside temperature (optional)", hidden: true, hideable: true) {
            input "temperatureSensor", "capability.temperatureMeasurement", required: false
            input "temperatureH", "number", title: "Switch to heating temperature", required: false, description: "Temperature below which switch to heat mode"
            input "temperatureC", "number", title: "Switch to cooling temperature", required: false, description: "Temperature above which switch to cool mode"
        }

        section("Advanced Settings", hidden: true, hideable: true) {
            input name: "batterySaver", type: "bool", title: "Save battery by skipping verification", description: "Disable this if schedules are not operating reliably", required: false, submitOnChange: false
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
        }

        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }
    }
}

// Globals
private getMIN_HEAT_TEMP_F() { 55 } // Keep a deadband diff between heat and cool
private getMAX_HEAT_TEMP_F() { 84 }
private getMIN_COOL_TEMP_F() { 60 }
private getMAX_COOL_TEMP_F() { 86 }
private getMIN_HEAT_TEMP_C() { 12 }
private getMAX_HEAT_TEMP_C() { 28 }
private getMIN_COOL_TEMP_C() { 15 }
private getMAX_COOL_TEMP_C() { 30 }

def installed() {
    log.debug "Installed with settings: ${settings}"
    initialize()
}

def updated() {
    log.debug "Updated with settings: ${settings}"
    initialize()
}

def initialize() {
    state.clientVersion = clientVersion()

    unsubscribe()
    unschedule() // clear any pending timers

    subscribe(temperatureSensor, "temperature", temperatureHandler)
    subscribe(remoteTemperatureSensor, "temperature", remoteChangeHandler) // Handle changes in remote temperature sensor and readjust thermostat
    subscribe(thermostat, "temperature", remoteChangeHandler) // Handle changes in thermostat temperature sensor and readjust thermostat
    subscribe(motionSensor, "motion.active", activeMotionHandler)
    subscribe(motionSensor, "motion.inactive", inactiveMotionHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize app
    
    if (startTime) { // Check motion sensors at beginning of schedule and set temperature accordingly
        schedule(startTime, scheduleStartTemperature)
    }

    if (endTime) { // At the end time we force a Idle temp for safety
        schedule(endTime, scheduleEnd)
    }

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    // Update the new temperature based on current state
    if (motionSensor?.any { sensor -> sensor.currentValue("motion") == "active" }) {
        checkAndSetActiveTemperature()
    } else {
        checkAndSetIdleTemperature()
    }
}

// Reinitialize app on user request
def changeHandler(evt) {
    log.debug "Reinitializing app on user request, name: ${evt?.name}, value: ${evt?.value}, Description: ${evt?.descriptionText}"
    initialize()
}

// This section sets the HVAC mode based outside temperature. HVAC fan mode is set to "auto".
def temperatureHandler(evt) {
    log.debug "Heat mode switch temperature $temperatureH, cool mode switch temperature $temperatureC"

    if (temperatureH == null || temperatureC == null) { // We are in Auto mode or user doesn't want us to switch modes
        return
    }

    def extTemp = temperatureSensor.currentTemperature
    log.debug "External temperature is: $extTemp"
    def thermostatState = thermostat?.currentThermostatMode
    def thermostatFan = thermostat?.currentThermostatFanMode
    log.debug "HVAC current mode $thermostatState"
    log.debug "HVAC Fan current mode $thermostatFan"
    if (extTemp < temperatureH) {
        if (thermostatState == "cool") {
            def hvacmode = "heat"
            thermostat?.setThermostatMode(hvacmode)
            log.debug "HVAC mode set to $hvacmode"
        }
    }
    else if (extTemp > temperatureC) {
        if (thermostatState == "heat") {
            def hvacmode = "cool"
            thermostat?.setThermostatMode(hvacmode)
            log.debug "HVAC mode set to $hvacmode"
        }
    }

    if (thermostatFan != "auto") {
        thermostat?.setThermostatFanMode("auto")
        log.debug "HVAC fan mode set to auto"
    }
}

// Handle remote temp sensor, set temperature if using a remote sensor
def remoteChangeHandler(evt) {
    log.debug "Reinitializing thermostats on temperature sensor change notification, name: ${evt.name}, value: ${evt.value}"

    if (atomicState.activeTemp) { // If we are on active temp mode then recalibrate the thermostat based on temp feedback from remote sensor
        checkAndSetActiveTemperature()
    } else {
        checkAndSetIdleTemperature()
    }
}

// Check if any motion sensors at active at the beginning of a schedule
def scheduleStartTemperature() {
    // Update the new temperature based on current state
    if (motionSensor?.any { sensor -> sensor.currentValue("motion") == "active" }) {
        log.debug "Found an active motion sensor at start of schedule, setting Active temperature"
        checkAndSetActiveTemperature() // Active mode
    } else {
        log.debug "No active motion sensors found at start of schedule, setting Idle temperature"
        checkAndSetIdleTemperature() // Idle mode
    }

    if (startTime) { // Reschedule to avoid the issue with platform not automatically adjusting for DST
        schedule(startTime, scheduleStartTemperature)
    }

    unschedule(checkAndSetIdleTemperature) // clear any pending timers
}

// Final safety Idle at end of schedule, set Idle if it's not already idle
def scheduleEnd() {
    log.debug "Operating schedule end, forcing the Idle temperature to $idHeatSet and $idCoolSet"
    //sendNotificationEvent("Forcing $thermostat to Idle temperature $idHeatSet and $idCoolSet")
    setIdleTemperature(idHeatSet, idCoolSet)

    if (endTime) { // Reschedule to avoid the issue with platform not automatically adjusting for DST
        schedule(endTime, scheduleEnd)
    }

    unschedule(checkAndSetIdleTemperature) // clear any pending timers
}

def inactiveMotionHandler(evt) {
    // Don't unschedule here since pending idle events need to complete as scheduled to avoid infinite loop e.g. delay set to 20 minutes, idle event comes every 5 minutes
    log.debug "Stop motion detected from ${evt?.displayName}, checking if any motion sensors are active"
    
    if (!checkSchedule()) {
        log.trace("Outside operating schedule, ignoring stop motion events")
        return
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    for (sensor in motionSensor) {
        if (sensor.currentValue("motion") == "active") {
            log.trace "$sensor shows active motion, NOT setting to idle mode"
            return
        }
    }

    if (idleTimeout != 0) {
        log.debug "No motion detected from any sensors, scheduling switch to idle mode in $idleTimeout minutes"
        def schTime = new Date(now() + (idleTimeout * 60 * 1000)) // current time plus idleTimeout in minutes
        runOnce(schTime, checkAndSetIdleTemperature) // Set idle mode after last sensor reports no motion so overwrite schedule
        log.trace "Scheduled idle mode switch at ${schTime.format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    } else {
        log.debug "No motion detected from any sensors, Setting the idle temperatures to $idHeatSet and $idCoolSet"
        //sendNotificationEvent("All motion sensors idle, setting $thermostat to $idHeatSet and $idCoolSet")
        checkAndSetIdleTemperature()
    }
}

def activeMotionHandler(evt) {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and re-validate your settings"
        log.warn msg
        runIn(1, initialize) // Reinitialize the app offline to avoid a loop
        sendPush(msg) // Do this in the end as it may timeout
        return
    }

    unschedule(checkAndSetIdleTemperature) // clear any pending timers for idle, we detected motion
    log.debug("Active motion detected from ${evt?.displayName}, initiating operating temperature set")
    checkAndSetActiveTemperature()
}

// Check if we are within scheduled times/days
private Boolean checkSchedule() {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentDT = new Date(now())
    def scheduledStart = (startTime != null) ? timeToday(startTime, timeZone) : null
    def scheduledEnd = (endTime != null) ? timeToday(endTime, timeZone) : null

    // some debugging in order to make sure things are working correclty
    log.trace("Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
              "\nOperating DOW(s): $dayOfWeek" +
              "\nOperating Start ${scheduledStart?.format("EEE MMM dd yyyy HH:mm z", timeZone)}, End ${scheduledEnd?.format("EEE MMM dd yyyy HH:mm z", timeZone)}")

    // Check if we are within operating times
    if (startTime != null && endTime != null) {
        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) { // If we between midnight and midday
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            //log.trace "Outside operating temperature schedule"
            return doChange
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    if(dayOfWeek.contains('All Week')) {
        doChange = true
    }
    else if((dayOfWeek.contains('Monday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Tuesday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Wednesday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Thursday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Friday') || dayOfWeek.contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Saturday') || dayOfWeek.contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    }

    else if((dayOfWeek.contains('Sunday') || dayOfWeek.contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    return doChange
}

def checkAndSetActiveTemperature() {
    // If we are within the schedule then do it
    if(checkSchedule()){
        log.debug("Setting the operating temperature to $opHeatSet and $opCoolSet")
        //sendNotificationEvent("Setting $thermostat to $opHeatSet and $opCoolSet")
        setActiveTemperature(opHeatSet, opCoolSet)
    } else {
        log.trace("Outside operating schedule, not setting Active temperatures")
    }
}

// Check if we within scheduled and then set the idle temperatures
def checkAndSetIdleTemperature() {
    // If we are within the schedule then do it
    if(checkSchedule()){
        log.debug("Setting the Idle temperature to $idHeatSet and $idCoolSet")
        //sendNotificationEvent("Setting $thermostat to Idle temperature$idHeatSet and $idCoolSet")
        setIdleTemperature(idHeatSet, idCoolSet)
    } else {
        log.trace("Outside operating schedule, not setting Idle temperatures")
    }
}

// Set the idle thermostat temperature
private setIdleTemperature(heatSet, coolSet) {
    if (!thermostat) {
        log.error "No thermostat selected, not doing anything"
        return
    }
    
    if (!batterySaver || thermostat?.currentValue("heatingSetpoint") != heatSet) {
        thermostat?.setHeatingSetpoint(heatSet)
    }
    if (!batterySaver || thermostat?.currentValue("coolingSetpoint") != coolSet) {
        thermostat?.setCoolingSetpoint(coolSet)
    }

    atomicState.activeTemp = false // We are on idle temp mode, set in the end after thermostat has been updated
}

// Set the active thermostat temperature on thermostate and check remote temp sensor
private setActiveTemperature(heatSet, coolSet) {
    if (!thermostat) {
        log.error "No thermostat selected, not doing anything"
        return
    }
    
    atomicState.activeTemp = true // We are on active temp mode

    def coolingSetpoint = coolSet
    def heatingSetpoint = heatSet
    def thermostatState = thermostat.currentThermostatMode
    def thermostatCurrentHeating = thermostat.currentValue("heatingSetpoint")
    def thermostatCurrentCooling = thermostat.currentValue("coolingSetpoint")

    log.trace "Thermostat mode: $thermostatState, Target Heat: $heatingSetpoint°, Target Cool: $coolingSetpoint°"

    // Check for invalid configuration
    if ((thermostatState == "auto") && (heatingSetpoint > coolingSetpoint)) {
        log.error "INVALID CONFIGURATION: Target Heat temperature: $heatingSetpoint° is GREATER than Target Cool temperature: $coolingSetpoint°"
        log.error "Not changing temperature settings on thermostat, correct the SmartApp settings"
        return
    }

    if (remoteTemperatureSensor) { // Remote temperature sensor
        def locationScale = getTemperatureScale()
        def maxCTemp
        def minCTemp
        def maxHTemp
        def minHTemp
        if (locationScale == "C") {
            minCTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
            maxCTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
            minHTemp = MIN_HEAT_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
            maxHTemp = MAX_HEAT_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
            log.trace "Location is in Celsius, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
        } else {
            minCTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
            maxCTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
            minHTemp = MIN_HEAT_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
            maxHTemp = MAX_HEAT_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
            log.trace "Location is in Farenheit, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
        }

        def currentTemp = (remoteTemperatureSensor*.currentTemperature).sum()/(remoteTemperatureSensor*.currentTemperature).count { it } // Take the average temp of the remote temperature sensor(s) (manage transition from legacy code to new code)
        log.trace("Remote Sensor Current Temp: $currentTemp°, Swing Threshold: $threshold")

        if (thermostatState == "auto") {
            // Cooling first
            if ((currentTemp - coolingSetpoint) > threshold) { // Turn cool on
                if (!batterySaver || thermostatCurrentCooling != minCTemp) {
                    thermostat.setCoolingSetpoint(minCTemp) // Set to cool
                }
                if (!batterySaver || thermostatCurrentHeating != minHTemp) {
                    thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                }
                log.info "Cooling ON, Thermostat Cool: ${minCTemp}, Target: $coolingSetpoint°"
            } else if ((heatingSetpoint - currentTemp) > threshold) { // Heating second (order is important to avoid constant switching)
                if (!batterySaver || thermostatCurrentHeating != maxHTemp) {
                    thermostat.setHeatingSetpoint(maxHTemp) // Set to heat
                }
                if (!batterySaver || thermostatCurrentCooling != maxCTemp) {
                    thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                }
                log.info "Heating ON, Thermostat Heat: ${maxHTemp}, Target: $heatingSetpoint°"
            } else if (((coolingSetpoint - currentTemp) > threshold) || ((currentTemp - heatingSetpoint) > threshold)) { // Turn off - don't check valid mode
                if (!batterySaver || thermostatCurrentCooling != maxCTemp) {
                    thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                }
                if (!batterySaver || thermostatCurrentHeating != minHTemp) {
                    thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                }
                log.info "HVAC OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
            }
        } else if (thermostatState == "cool") {
            // air conditioner
            if ((currentTemp - coolingSetpoint) > threshold) { // Turn cool on
                if (!batterySaver || thermostatCurrentCooling != minCTemp) {
                    thermostat.setCoolingSetpoint(minCTemp) // Set to cool
                }
                log.info "Cooling ON, Thermostat: ${minCTemp}, Target: $coolingSetpoint°"
            } else if ((coolingSetpoint - currentTemp) > threshold) { // Turn cool off - don't check valid mode
                if (!batterySaver || thermostatCurrentCooling != maxCTemp) {
                    thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                }
                log.info "Cooling OFF, Thermostat Cool: ${maxCTemp}"
            }
        } else {
            // Heater or emergency heater
            if ((heatingSetpoint - currentTemp) > threshold) {
                if (!batterySaver || thermostatCurrentHeating != maxHTemp) {
                    thermostat.setHeatingSetpoint(maxHTemp) // Set to heat
                }
                log.info "Heating ON, Thermostat: ${maxHTemp}, Target: $heatingSetpoint°"
            } else if ((currentTemp - heatingSetpoint) > threshold) { // Disable heat - don't check valid mode
                if (!batterySaver || thermostatCurrentHeating != minHTemp) {
                    thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                }
                log.info "Heating OFF, Thermostat Heat: ${minHTemp}"
            }
        }
    } else { // Local thermostat
        if (thermostatState == "auto") {
            def msg = ""
            if (!batterySaver || thermostatCurrentHeating != heatingSetpoint) {
                thermostat.setHeatingSetpoint(heatingSetpoint)
                msg += "Set $thermostat Heat ${heatingSetpoint}°"
            }
            if (!batterySaver || thermostatCurrentCooling != coolingSetpoint) {
                thermostat.setCoolingSetpoint(coolingSetpoint)
                if (msg) {
                    msg += "Set $thermostat Cool ${coolingSetpoint}°"
                } else {
                    msg += ", Cool ${coolingSetpoint}°"
                }
            }
            if (msg) {
                log.info msg
            }
        } else if (thermostatState == "cool") {
            if (!batterySaver || thermostatCurrentCooling != coolingSetpoint) {
                thermostat.setCoolingSetpoint(coolingSetpoint)
                log.info "Set $thermostat Cool ${coolingSetpoint}°"
            }
        } else { // heater or emergency heater
            if (!batterySaver || thermostatCurrentHeating != heatingSetpoint) {
                thermostat.setHeatingSetpoint(heatingSetpoint)
                log.info "Set $thermostat Heat ${heatingSetpoint}°"
            }
        }
    }
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "Motion Based Thermostat",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Motion based thermostat"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ thermostat, motionSensor, remoteTemperatureSensor, temperatureSensor ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}


// THIS IS THE END OF THE FILE