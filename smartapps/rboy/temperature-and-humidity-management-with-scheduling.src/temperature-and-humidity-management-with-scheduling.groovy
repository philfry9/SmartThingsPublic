/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() { return "01.11.01" }

/**
 *  Extreme Humidity and Temperature Management
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 *
 * 2020-08-21 - (v01.11.01) Only send notifications if a device is turned off at end of schedule
 * 2020-07-31 - (v01.11.00) New app/platform improvements
 * 2020-05-04 - (v01.10.02) Try to detect platform outage and prevent code upgrade spam notifications
 * 2020-01-20 - (v01.10.01) Update icons for broken ST Android app 2.18
 * 2020-01-10 - (v01.10.00) Turn off climiate control devices once when out of operating mode and schedule
 * 2019-10-11 - (v01.09.02) Add support for the new Sonos integration (auto detect)
 * 2019-07-25 - (v01.09.01) Update thermostat setpoint for remote temperature sensors to be compatible with trane thermostat limits
 * 2019-05-21 - (v01.09.00) Pretty UI and fix scheduling bug, check for invalid SMS characters, added audio notifications
 * 2019-01-11 - (v01.08.03) Fix typo in push notification for low temperature, show configuration errors on temperature page, turn off devices at end of schedules only if they are configured to be used
 * 2019-01-08 - (v01.08.00) Updated UI, udpated temperature thresholds for better thermostat compatibility
 * 2018-04-09 - (v01.07.03) Reduce the amount of message in the notifications tab, only set device if current state is not in desired state
 * 2018-03-21 - (v01.07.02) Default temperature threshold is now 1 degree and report if the user has invalid temperature settings
 * 2018-01-06 - (v01.07.01) Turn off all devices when mode changes to non operating mode, run sanity check only when in selected modes
 * 2017-11-25 - (v01.07.00) Fixed and issue with humidity management and thresholds logic, added ability to configure temperature and humidity cutoff thresholds
 * 2017-11-22 - (v01.06.01) Update temperature settings for thermostats to be compatible with more thermostats
 * 2017-09-06 - (v01.06.00) Added support for expirations past midnight
 * 2017-05-26 - (v01.05.01) Multiple SMS numbers are now separate by a *
 * 2017-03-14 - (v1.5.0) Clarification of options and added option for humidifier
 * 2016-11-05 - Added support for automatic code update notifications and fixed an issue with sms
 * 2016-08-17 - Added support for ST contact address book
 * 2016-05-19 - If end time is after start time then assume the end time is next day
 * 2016-05-15 - Notify use if timezone/location is missing in setup
 * 2016-01-19 - Added scheduling options, also when in a non operating mode, it will not turn on devices but will turn off as a safetly measure
 * 2016-01-12 - Added notifications
 * 2016-01-11 - Initial version
*/
definition(
    name: "Temperature and Humidity Management with Scheduling",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Use your HVACs, fans, heaters and dehumidifiers to control the extreme humidity and temperatures",
    category: "Green Living",
    iconUrl: "https://www.rboyapps.com/images/TemperatureHumidity.png",
    iconX2Url: "https://www.rboyapps.com/images/TemperatureHumidity.png",
    iconX3Url: "https://www.rboyapps.com/images/TemperatureHumidity.png")

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
    page(name: "tempManagementPage")
    page(name: "humidityManagementPage")
    page(name: "operatingPage")
    page(name: "scheduleCodesPage")
}

// Globals
private getMIN_HEAT_TEMP_F() { 55 } // Keep a deadband diff between heat and cool
private getMAX_HEAT_TEMP_F() { 84 }
private getMIN_COOL_TEMP_F() { 60 }
private getMAX_COOL_TEMP_F() { 86 }
private getMIN_HEAT_TEMP_C() { 12 }
private getMAX_HEAT_TEMP_C() { 28 }
private getMIN_COOL_TEMP_C() { 15 }
private getMAX_COOL_TEMP_C() { 30 }
private getDefaultTempThreshold() { 1 } // Temperature threshold between upper and lower limits
private getDefaultHumidityThreshold() { 1 } // Dumidity threshold between upper and lower limits

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "Temperature and Humidity Management v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Temperature and Humidity Management v${clientVersion()}", install: true, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }
        
        def tempError = false
        def threshold = tempThreshold ?: defaultTempThreshold // Minimum difference in temperatures to make things happen
        if (highTemp && lowTemp) { // Sanity check to avoid hunting if we have both defined
            if ((highTemp - lowTemp) < (threshold * 2)) {
                tempError = true
            }
        }
        
        section() {
        	href(name: "tempManagement", title: "Temperature management", page: "tempManagementPage", description: tempManagementDescription(), required: false, image: "https://www.rboyapps.com/images/Temperature.png")
        	href(name: "humidityManagement", title: "Humidity management", page: "humidityManagementPage", description: humidityManagementDescription(), required: false, image: "https://www.rboyapps.com/images/Humidity.png")
        	href(name: "operating", title: "Operating schedules", page: "operatingPage", description: schedulingDescription(), required: false, image: "https://www.rboyapps.com/images/Scheduling.png")
        }

        section("Notification Options") {
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false, image: "https://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers by separating them with a '*'\nE.g. 5551234567*+18747654321"
                input "sms", "phone", title: "Send SMS notification to", required: false, image: "https://www.rboyapps.com/images/Notifications.png"
                input "push", "bool", title: "Send push notifications", required: false, image: "https://www.rboyapps.com/images/PushNotification.png"
            }
            input "audioDevices", "capability.audioNotification", title: "Speak notifications on", required: false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/Horn.png"
            if (audioDevices) {
                input "audioVolume", "number", title: "...at this volume level (optional)", description: "keep current", required: false, range: "1..100"
            }
        }
        section("Advanced Settings", hidden: !tempError, hideable: true) {
            if (tempError) {
                paragraph title: "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold", required: true, ""
                log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
            }
            input "tempThreshold", "number", title: "Temperature swing threshold (°)", description: "High/low temperature swing cutoff level", required: true, defaultValue: defaultTempThreshold, range: "1..10", submitOnChange: true
            input "humidityThreshold", "number", title: "Humidity swing threshold (%)", description: "High/low humidity swing cutoff level", required: true, defaultValue: defaultHumidityThreshold, range: "1..20"
            label title: "Assign a name for this SmartApp", required: false
            input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
        }
        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }
    }
}


private tempManagementDescription() {
    ((highTemperatureSensor && (thermostatsCool || fans)) || (lowTemperatureSensor && (thermostatsHeat || heaters))) ? "Configured" : ""
}

def tempManagementPage() {
    dynamicPage(name: "tempManagementPage", title: "Temperature Management") {
        def tempError = false
        def threshold = tempThreshold ?: defaultTempThreshold // Minimum difference in temperatures to make things happen
        if (highTemp && lowTemp) { // Sanity check to avoid hunting if we have both defined
            if ((highTemp - lowTemp) < (threshold * 2)) {
                tempError = true
            }
        }
        
        section("High temperature management") {
            paragraph "This corresponds to the cooling setpoint of a thermostat, if the temperature exceeds this setting it will turn on the cooling options to maintain the temperature at this level"
            input "highTemperatureSensor", "capability.temperatureMeasurement", title: "High temperature sensor", required: false, multiple:false, submitOnChange: true
            if (highTemperatureSensor) {
                if (tempError) {
                    paragraph title: "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold", required: true, ""
                    log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
                }
                input "highTemp", "number", title: "If the temperature rises above...", required: true, submitOnChange: true
                input "thermostatsCool", "capability.thermostat", title: "...turn on these HVAC(s)...", required: false, multiple:true
                input "fans", "capability.switch", title: "...turn on these coolers(s)", required: false, multiple:true
            }
        }

        section("Low Temperature management") {
            paragraph "This corresponds to the heating setpoint of a thermostat, if the temperature falls below this setting it will turn on the heating options to maintain the temperature at this level"
            input "lowTemperatureSensor", "capability.temperatureMeasurement", title: "Low temperature sensor", required: false, multiple:false, submitOnChange: true
            if (lowTemperatureSensor) {
                if (tempError) {
                    paragraph title: "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold", required: true, ""
                    log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
                }
                input "lowTemp", "number", title: "If the temperature falls below...", required: true, submitOnChange: true
                input "thermostatsHeat", "capability.thermostat", title: "...turn on these HVAC(s)...", required: false, multiple:true
                input "heaters", "capability.switch", title: "...turn on these heaters(s)...", required: false, multiple:true
            }
        }
    }
}

private humidityManagementDescription() {
    (humiditySensor && ((highHumidity && (thermostatsDehumidify || dehumidifiers)) || (lowHumidity && humidifiers))) ? "Configured" : ""
}

def humidityManagementPage() {
    dynamicPage(name: "humidityManagementPage", title: "Humidity Management") {
        section() {
            input "humiditySensor", "capability.relativeHumidityMeasurement", title: "Humidity sensor", required: false, multiple:false, submitOnChange: true
            if (humiditySensor) {
                input "highHumidity", "number", title: "If the humidity rises above (%)...", required: false, submitOnChange: true
                if (highHumidity) {
                    input "thermostatsDehumidify", "capability.thermostat", title: "...turn on these HVAC(s)...", required: false, multiple:true
                    input "dehumidifiers", "capability.switch", title: "...turn on these dehumidifiers(s)", required: false, multiple:true
                    paragraph ""
                }
                input "lowHumidity", "number", title: "If the humidity falls below (%)...", required: false, submitOnChange: true
                if (lowHumidity) {
                    input "humidifiers", "capability.switch", title: "...turn on these humidifiers(s)", required: false, multiple:true
                }
            }
        }
    }
}

private schedulingDescription() {
    ((0..2).any { i -> settings."userDayOfWeek${"A"}${i}" } || modeMonitor) ? "Configured" : ""
}

def operatingPage() {
    dynamicPage(name: "operatingPage", title: "", install: false, uninstall: false) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section("Operating Schedules and Modes") {
            input "modeMonitor", "mode", title: "Enable system only when in this mode(s)", required: false, multiple: true // Mode is now optional when we have operating schedules

            // 3 schedule options
            (0..2).each { user ->
                def hrefParams = [
                    user: user as String,
                    schedule: "A",
                    passed: true
                ]
                href(name: "schedule${user}", params: hrefParams, title: "Click here to define schedule ${user + 1}", page: "scheduleCodesPage", description: (settings."userDayOfWeek${"A"}${user}" ? "${settings."userDayOfWeek${"A"}${user}"}: ${settings."userStartTime${"A"}${user}" ? (new Date(timeToday(settings."userStartTime${"A"}${user}", timeZone).time)).format("HH:mm z", timeZone) : ""} - ${settings."userEndTime${"A"}${user}" ? (new Date(timeToday(settings."userEndTime${"A"}${user}", timeZone).time)).format("HH:mm z", timeZone) : ""}" : "Not defined"), required: false)
            }
        }
    }
}

// Check if any valid operating schedule is defined
private anySchedule() {
    def defined = false
    (0..2).each { user ->
        if (settings."userDayOfWeek${"A"}${user}") {
            defined = true
        }
    }
    
    return defined
}

def scheduleCodesPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def user = params?.user ?: ""
    def schedule = params?.schedule ?: ""

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${(user as Integer) + 1}", uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.debug "Schedule:$schedule, User:$i, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                description: "Not defined",
                required: false,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ]
        }
    }
}

def installed() {
    log.debug "Installed"

    if (!modeMonitor || modeMonitor.contains(location.mode)) { // Empty means all modes
        runIn(1, sanityCheck) // Defer it so that it only runs in the selected modes
    }
    subscribeToEvents()
}

def updated() {
    log.debug "Updated"
    
    unsubscribe()
    unschedule()
    if (!modeMonitor || modeMonitor.contains(location.mode)) { // Empty means all modes
        runIn(1, sanityCheck) // Defer it so that it only runs in the selected modes
    }
    subscribeToEvents()
}

def subscribeToEvents() {
    log.debug "Initialized with $settings"

    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades

    subscribe(highTemperatureSensor, "temperature", highTemperatureHandler)
    subscribe(lowTemperatureSensor, "temperature", lowTemperatureHandler)
    subscribe(humiditySensor, "humidity", humidityHandler)
    subscribe(location, "mode", modeChangeHandler)

    runEvery5Minutes(heartBeat) // Since we have a heartbeat we don't need kick start timers
    
    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    def threshold = tempThreshold ?: defaultTempThreshold // Minimum difference in temperatures to make things happen
    if (highTemperatureSensor && lowTemperatureSensor) { // Sanity check to avoid hunting if we have both defined
        if ((highTemp - lowTemp) < (threshold * 2)) {
            log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
            sendPush("INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold")
        }
    }
}

def modeChangeHandler(evt) {
    log.debug "Mode change notification, name: ${evt.name}, value: ${evt.value}"

    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and re-validate your settings"
        log.warn msg
        runIn(1, subscribeToEvents) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        //sendPush(msg) // Do this in the end as it may timeout
        return
    }

    if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes
        if (true || !state.turnedOff) { // Only turn off devices once so as not to interfere with other apps
            def msg = "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, turning off climate control devices"
            log.info msg
            if (turnOffAllDevices()) {
                sendNotifications(msg)
            }
        } else {
            log.trace "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, climate control devices already turned off"
        }
    }
}

// Check if we are out of operating schedule
def heartBeat() {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and re-validate your settings"
        log.warn msg
        runIn(1, subscribeToEvents) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        //sendPush(msg) // Do this in the end as it may timeout
        return
    }

    if (modeMonitor && !modeMonitor.contains(location.mode)) { // If we aren't in the operating mode, skip this check
        if (!state.turnedOff) { // Only turn off devices once so as not to interfere with other apps
            def msg = "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, turning off climate control devices"
            log.info msg
            if (turnOffAllDevices()) {
                sendNotifications(msg)
            }
        } else {
            log.trace "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, climate control devices already turned off"
        }
    }
    
    if (anySchedule() && !(0..2).any { user -> checkSchedule(user, "A") }) { // Check if we are within operating Schedule
        if (!state.turnedOff) {
            def msg = "End of operating schedule, turning off climate control devices"
            log.info msg
            if (turnOffAllDevices()) {
                sendNotifications(msg)
            }
        } else {
            log.trace "Out of operating schedule, climate controls devices already off"
        }
    }
}

private turnOffAllDevices() {
    log.debug "Turning off all devices"
    
    def retAction = false

    def locationScale = getTemperatureScale()
    def maxCTemp
    def minCTemp
    def maxHTemp
    def minHTemp
    if (locationScale == "C") {
        minCTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxCTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        minHTemp = MIN_HEAT_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxHTemp = MAX_HEAT_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
    } else {
        minCTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxCTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        minHTemp = MIN_HEAT_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxHTemp = MAX_HEAT_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
    }

    if (highTemperatureSensor) { // If these devices are active
        if (thermostatsCool) {
            retAction |= thermostatsCool.any { it.currentValue("coolingSetpoint") != maxCTemp } // Check if any action is required
            thermostatsCool.setCoolingSetpoint(maxCTemp) // Disable
            log.info "HVAC OFF, set cool: ${maxCTemp}"
        }
        if (fans) {
            retAction |= fans.any { it.currentValue("switch") == "on" } // Check if any action is required
            fans.off()
            log.info "Cooling fans off"
        }
    }
    
    if (lowTemperatureSensor) { // If these devices are active
        if (thermostatsHeat) {
            retAction |= thermostatsHeat.any { it.currentValue("heatingSetpoint") != minHTemp } // Check if any action is required
            thermostatsHeat.setHeatingSetpoint(minHTemp) // Disable
            log.info "HVAC OFF, set heat: ${minHTemp}"
        }
        if (heaters) {
            retAction |= heaters.any { it.currentValue("switch") == "on" } // Check if any action is required
            heaters.off()
            log.info "Heaters off"
        }
    }
    
    if (humiditySensor && highHumidity) { // Only if devices are active
        if (thermostatsDehumidify) {
            retAction |= thermostatsDehumidify.any { it.currentValue("coolingSetpoint") != maxCTemp } // Check if any action is required
            thermostatsDehumidify.setCoolingSetpoint(maxCTemp) // Disable
            log.info "Dehumidify HVAC OFF, set cool: ${maxCTemp}"
        }
        if (dehumidifiers) {
            retAction |= dehumidifiers.any { it.currentValue("switch") == "on" } // Check if any action is required
            dehumidifiers.off()
            log.info "Dehumidifiers off"
        }
    }
    
    if (humiditySensor && lowHumidity) { // Only if devices are active
        if (humidifiers) {
            retAction |= humidifiers.any { it.currentValue("switch") == "on" } // Check if any action is required
            humidifiers.off()
            log.info "Humidifiers off"
        }
    }
    
    state.turnedOff = true // We're done turning everything off
    
    return retAction
}

// Check and initialize current state
def sanityCheck() {
    highTemperatureHandler()
    lowTemperatureHandler()
    humidityHandler()
}

def highTemperatureHandler(evt) {
    log.debug "High temperature sensor change notification, name: ${evt?.name}, value: ${evt?.value}"

    // A/C
    def threshold = tempThreshold ?: defaultTempThreshold // Minimum difference in temperatures to make things happen
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (highTemperatureSensor) {
        def currentTemp = highTemperatureSensor.currentTemperature
        log.trace("High Temp Sensor Current Temp: $currentTemp°")

        if (highTemperatureSensor && lowTemperatureSensor) { // Sanity check to avoid hunting if we have both defined
            if ((highTemp - lowTemp) < (threshold * 2)) {
                log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
                sendPush("INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold")
                return
            }
        }

        if (anySchedule() && !(0..2).any { user -> checkSchedule(user, "A") }) { // Check if we are within operating Schedule
            if (!state.turnedOff) {
                def msg = "End of operating schedule, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Out of operating schedules, skipping high temp sensor"
            }
            return // We're done
        } else if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
            if (!state.turnedOff) {
                def msg = "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping high temp sensor"
            }
            return // We're done
        } else {
            state.turnedOff = false // Reset operation as we are in schedule
        }

        if (currentTemp > highTemp) { // Turn cool on
            if (thermostatsCool?.any { it.currentValue("coolingSetpoint") != minTemp }) {
                thermostatsCool.setCoolingSetpoint(minTemp) // Set to cool
                log.info "HVAC ON, set cool: ${minTemp}"
                sendNotifications("High temperature $currentTemp, turning on HVAC cool")
            }
            if (fans?.any { it.currentValue("switch") != "on" }) {
                fans.on()
                log.info "Cooling fans on"
                sendNotifications("High temperature $currentTemp, turning on fans")
            }
        } else if (currentTemp <= (highTemp - threshold)) { // Turn cool off
            if (thermostatsCool?.any { it.currentValue("coolingSetpoint") != maxTemp }) {
                thermostatsCool.setCoolingSetpoint(maxTemp) // Disable
                log.info "HVAC OFF, set cool: ${maxTemp}"
                sendNotifications("Temperature reduced $currentTemp, turning off HVAC")
            }
            if (fans?.any { it.currentValue("switch") != "off" }) {
                fans.off()
                log.info "Cooling fans off"
                sendNotifications("Temperature reduced $currentTemp, turning off fans")
            }
        }
    }
}

def lowTemperatureHandler(evt) {
    log.debug "Low temperature sensor change notification, name: ${evt?.name}, value: ${evt?.value}"

    // Heater
    def threshold = tempThreshold ?: defaultTempThreshold // Minimum difference in temperatures to make things happen
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = MIN_HEAT_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_HEAT_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = MIN_HEAT_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_HEAT_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (lowTemperatureSensor) {
        def currentTemp = lowTemperatureSensor.currentTemperature
        log.trace("Low Temp Sensor Current Temp: $currentTemp°")
        
        if (highTemperatureSensor && lowTemperatureSensor) { // Sanity check to avoid hunting if we have both defined
            if ((highTemp - lowTemp) < (threshold * 2)) {
                log.error "INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold"
                sendPush("INVALID CONFIGURATION: Upper temperature threshold must be atleast ${(threshold * 2)}° higher than Lower temperature threshold")
                return
            }
        }

        if (anySchedule() && !(0..2).any { user -> checkSchedule(user, "A") }) { // Check if we are within operating Schedule
            if (!state.turnedOff) {
                def msg = "End of operating schedule, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Out of operating schedules, skipping low temp sensor"
            }
            return // We're done
        } else if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
            if (!state.turnedOff) {
                def msg = "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping low temp sensor"
            }
            return // We're done
        } else {
            state.turnedOff = false // Reset operation as we are in schedule
        }

        if (currentTemp < lowTemp) { // Turn heat on
            if (thermostatsHeat?.any { it.currentValue("heatingSetpoint") != maxTemp }) {
                thermostatsHeat.setHeatingSetpoint(maxTemp) // Set to heat
                log.info "HVAC ON, set heat: ${maxTemp}"
                sendNotifications("Low temperature $currentTemp, turning on HVAC heat")
            }
            if (heaters?.any { it.currentValue("switch") != "on" }) {
                heaters.on()
                log.info "Heaters on"
                sendNotifications("Low temperature $currentTemp, turning on heaters")
            }
        } else if (currentTemp >= (lowTemp + threshold)) { // Turn heat off
            if (thermostatsHeat?.any { it.currentValue("heatingSetpoint") != minTemp }) {
                thermostatsHeat.setHeatingSetpoint(minTemp) // Disable
                log.info "HVAC OFF, set heat: ${minTemp}"
                sendNotifications("Temperature increased $currentTemp, turning off HVAC")
            }
            if (heaters?.any { it.currentValue("switch") != "off" }) {
                heaters.off()
                log.info "Heaters off"
                sendNotifications("Temperature increased $currentTemp, turning off heaters")
            }
        }
    }
}

def humidityHandler(evt) {
    log.debug "Humidity sensor change notification, name: ${evt?.name}, value: ${evt?.value}"

    // High humidity
    def threshold = humidityThreshold ?: defaultHumidityThreshold // Threshold between on and off
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        minTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    } else {
        minTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp for thermostat"
    }

    if (humiditySensor) {
        def currentHumidity = humiditySensor.currentHumidity
        log.trace("Humidity Sensor Current humidity: $currentHumidity%")

        if (highHumidity && lowHumidity) { // Sanity check to avoid hunting if we have both defined
            if ((highHumidity - lowHumidity) < (threshold * 2)) {
                log.error "INVALID CONFIGURATION: Upper humidity threshold must be atleast ${(threshold * 2)}% higher than Lower humidity threshold"
                sendPush("INVALID CONFIGURATION: Upper humidity threshold must be atleast ${(threshold * 2)}% higher than Lower humidity threshold")
                return
            }
        }

        if (anySchedule() && !(0..2).any { user -> checkSchedule(user, "A") }) { // Check if we are within operating Schedule
            if (!state.turnedOff) {
                def msg = "End of operating schedule, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Out of operating schedules, skipping humidity sensor"
            }
            return // We're done
        } else if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes, only turn on if we are in a supported mode (turn off to avoid over heating/cooling even if not in active mode)
            if (!state.turnedOff) {
                def msg = "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, turning off climate controls"
                log.info msg
                if (turnOffAllDevices()) {
                    sendNotifications(msg)
                }
            } else {
                log.trace "Current mode ${location.mode} is not in the list of operating modes $modeMonitor, skipping humidity sensor"
            }
            return // We're done
        } else {
            state.turnedOff = false // Reset operation as we are in schedule
        }

        // Dehumidifier
        if (highHumidity) {
            if (currentHumidity > highHumidity) { // Turn on
                if (thermostatsDehumidify?.any { it.currentValue("coolingSetpoint") != minTemp }) {
                    thermostatsDehumidify.setCoolingSetpoint(minTemp) // Set to cool
                    log.info "Dehumidify HVAC ON, set cool: ${minTemp}"
                    sendNotifications("High humidity $currentHumidity%, turning on HVAC cool")
                }
                if (dehumidifiers?.any { it.currentValue("switch") != "on" }) {
                    dehumidifiers.on()
                    log.info "Dehumidifiers on"
                    sendNotifications("High humidity $currentHumidity%, turning on dehumidifiers")
                }
            } else if (currentHumidity <= (highHumidity - threshold)) { // Turn off
                if (thermostatsDehumidify?.any { it.currentValue("coolingSetpoint") != maxTemp }) {
                    thermostatsDehumidify.setCoolingSetpoint(maxTemp) // Disable
                    log.info "Dehumidify HVAC OFF, set cool: ${maxTemp}"
                    sendNotifications("Humidity reduced $currentHumidity%, turning off HVAC")
                }
                if (dehumidifiers?.any { it.currentValue("switch") != "off" }) {
                    dehumidifiers.off()
                    log.info "Dehumidifiers off"
                    sendNotifications("Humidity reduced to $currentHumidity%, turning off Dehumidifiers")
                }
            }
        } else {
            log.trace "No upper humidity setpoint defined"
        }

        // Humidifier
        if (lowHumidity) {
            if (currentHumidity < lowHumidity) { // Turn on
                if (humidifiers?.any { it.currentValue("switch") != "on" }) {
                    humidifiers.on()
                    log.info "Humidifiers on"
                    sendNotifications("Low humidity $currentHumidity%, turning on humidifiers")
                }
            } else if (currentHumidity >= (lowHumidity + threshold)) { // Turn off
                if (humidifiers?.any { it.currentValue("switch") != "off" }) {
                    humidifiers.off()
                    log.info "Humidifiers off"
                    sendNotifications("Humidity increased to $currentHumidity%, turning off Humidifiers")
                }
            }
        } else {
            log.trace "No lower humidity setpoint defined"
        }
    }
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}" - optional
// settings."userEndTime${x}${i}" - optional
// settings."userDayOfWeek${x}${i}" - required
private checkSchedule(def i, def x) {
    log.trace "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.trace "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" && settings."userEndTime${x}${i}") {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.trace "Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}"

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug "Outside operating time schedule"
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.trace "Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}"

    if(!settings."userDayOfWeek${x}${i}") {
        log.debug "Day of week not specified for operating schedule $x for user $i"
        return false
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.replaceAll("[;,#]", "*").split("\\*") // Some users accidentally use ;,# instead of * and ST can't handle *,#+ in the number except for + at the beginning
        for (phone in phones) {
            try {
                sendSms(phone, message)
            } catch (Exception e) {
                sendPush "Invalid phone number $phone"
            }
        }
    }
}

private void sendNotifications(message) {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (push) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }

    audioDevices?.each { audioDevice -> // Play audio notifications
        if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTextAndResume(message, audioVolume)
            } else {
                audioDevice.playText(message)
            }
        } else {
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
            } else {
                audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
            }
        }
    }
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "Temperature and Humidity Management",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Temperature and Humidity Management with Scheduling"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ highTemperatureSensor, thermostatsCool, fans, lowTemperatureSensor, thermostatsHeat, heaters, humiditySensor, thermostatsDehumidify, dehumidifiers, humidifiers ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE