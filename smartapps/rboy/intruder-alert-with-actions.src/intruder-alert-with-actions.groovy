/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 

def clientVersion() { return "04.05.03" }

/**
 * Intruder Alert with Actions
 *
 * Copyright RBoy Apps, modification, reuse or redistribution of code is not allowed without permission
 * 2020-09-09 - (v04.05.03) Fix invalid state only for affected keypad while arming
 * 2020-09-01 - (v04.05.02) Update for retirement of Classic app
 * 2020-07-29 - (v04.05.01) New app/platform improvements
 * 2020-06-26 - (v04.04.07) Exit delay limit 1 to 5 minutes, entry delay 30 seconds to 5 minutes
 * 2020-06-19 - (v04.04.06) Add support for Z-Wave keypad devices
 * 2020-05-04 - (v04.04.05) Try to detect platform outage and prevent code upgrade spam notifications
 * 2020-03-20 - (v04.04.04) Fix for ST platform not disarming system on mode change sometimes
 * 2020-01-20 - (v04.04.03) Update icons for broken ST Android app 2.18
 * 2019-12-10 - (v04.04.02) Restore keypad armed state if set
 * 2019-10-11 - (v04.04.01) Add support for the new Sonos integration (auto detect)
 * 2019-08-30 - (v04.03.01) Added option for None and Speak in notifications play
 * 2019-08-23 - (v04.03.00) Added support for playing audio notifications like SHM
 * 2019-06-20 - (v04.02.00) Added support for beeping keypads on entry/exit delay and locks as condition for arming, improved accuracy of exit countdown, Don't resume playback if no audio volume is specified
 * 2019-06-19 - (v04.01.00) Update text for arming/disarming instead of operating configuration, add support for vibration sensors as triggers
 * 2019-06-14 - (v04.00.02) Fix SHM mode change notification grammar
 * 2019-06-11 - (v04.00.01) Added volume option for spoken notifications
 * 2019-06-05 - (v04.00.00) Added support for switches, SHM modes and presence sensors as conditions for activation, notify when disarming
 * 2019-05-21 - (v03.07.02) Code clean up
 * 2019-05-16 - (v03.07.01) Updated icon for app
 * 2019-04-30 - (v03.07.00) Fix platform resetting modes, better check while arming and disarming across multiple modes, announce disarming
 * 2019-04-26 - (v03.06.02) Resident sensor explanation, include app name in notifications, check for invalid SMS numbers
 * 2019-04-25 - (v03.06.00) Countdown timers for entry and exit delays (30 second increments), don't reset entry delay timer if multiple events are detected
 * 2018-12-06 - (v03.05.00) Revamped UI, added option for running Routine on Intruder actions, Entry delay applies to all actions
 * 2018-12-05 - (v03.04.01) Minor updates to UI
 * 2018-05-08 - (v03.04.00) Always run alarm actions even if active until it's disabled, fix for retriggering after initial alarm
 * 2018-02-21 - (v03.03.00) Fix for delay alarm, applies to silent and non silent alarms, fix for resident contact sensors, streamlined options
 * 2018-02-07 - (v03.02.00) Added support for a panic switch,button to set off the alarm and resident contact sensors
 * 2018-01-09 - (v03.00.00) Added support for defining  upto 3 operating schedules
 * 2018-01-08 - (v02.04.00) Added support for disabling push notifications, added support for playing backing messages on audio devices
 * 2017-05-26 - (v02.03.00) Added support for automatic reseting of the app when no Alarm is used, disabled flashing lights, improved responsiveness
 * 2017-05-26 - (v02.02.00) Added notifications when all alarms are turned off when a single alarm is detected to be turned off, added support for multiple SMS number notifications by separating with a *
 * 2016-11-03 - Added support for tamper devices and for automatic code updates
 * 2016-10-22 - Empty/no delay time now sets it to immediate arming
 * 2016-08-31 - Fix for SMS not being sent, added support for arming notifications, improved system arming setup
 * 2016-08-17 - Added version and workaround for ST contact address book bug
 * 2016-02-22 - Include alarm source details when sending alarm notifications
 * 2016-01-17 - You can specify multiple sms phone numbers by putting a + to separate them
 * 2016-01-05 - Added support to set off alarm when a door is unlocked
 * 2015-11-27 - Added support to set dimmer levels to 100% while turning on the lights
 * 2015-02-15 - Bug fix for lights not coming on, change input to phone number for text message
 * 2015-02-02 - Added support for turning on lights/switches
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */
definition(
    name: "Intruder Alert with Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Alerts you when there are intruders, turns on lights/cameras/alarms with entry/exit delays and resident sensors",
    category: "Safety & Security",
    iconUrl: "https://www.rboyapps.com/images/SecurityDetection.png",
    iconX2Url: "https://www.rboyapps.com/images/SecurityDetection.png"
)

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
    page(name: "armingPage")
    page(name: "alarmsPage")
    page(name: "operatingPage")
    page(name: "notificationsPage")
    page(name: "scheduleCodesPage")
}

private getCountdownInterval() { 29 } // Announce every X seconds
private getCheckInterval() { 1 } // Check for re-arm / dis-arm every 1 minute
private getKeypadBeepDelay() { 3 } // Delays in second before starting keypad beep, to avoid conflict with other apps using SHM sync with keypad

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "Intruder Alert with Actions v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Intruder Alert with Actions v${clientVersion()}", install: true, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section() {
        	href(name: "arming", title: "Intrusion Detection", page: "armingPage", description: "", required: false, image: "https://www.rboyapps.com/images/SecurityDetection.png")
        	href(name: "alarms", title: "Intrusion Actions", page: "alarmsPage", description: "", required: false, image: "https://www.rboyapps.com/images/SecurityAlarm.png")
        	href(name: "scheduling", title: "Arm/Disarm Settings", page: "operatingPage", description: "", required: false, image: "https://www.rboyapps.com/images/Scheduling.png")
        	href(name: "notifications", title: "Notifications", page: "notificationsPage", description: "", required: false, image: "https://www.rboyapps.com/images/NotificationsD.png")
    	}
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "updateNotifications", title: "Check for app updates", type: "bool", defaultValue: true, required: false
        }
        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }
    }
}

def armingPage() {
    dynamicPage(name: "armingPage", title: "", install: false, uninstall: false) {
        section("Intruder Detection Sensors") {
            input "intrusionMotions", "capability.motionSensor", title: "Motion sensors", multiple: true, required: false
            input "intrusionContacts", "capability.contactSensor", title: "Contact sensors", multiple: true, required: false
            input "intrusionLocks", "capability.lock", title: "Door locks", multiple: true, required: false
            input "vibrationDevices", "capability.accelerationSensor", title: "Vibration sensors", multiple: true, required: false
            input "tamperDevices", "capability.tamperAlert", title: "Tamper devices", multiple: true, required: false
        }
        
        section("Panic Alarm Devices") {
            input "panicSwitches", "capability.switch", title: "Panic switch", multiple: true, required: false
            input "panicButtons", "capability.button", title: "Panic button", multiple: true, required: false
        }
        
        section("Resident Detection Sensors") {
            paragraph "Ignore intruder sensors if residents are active"
            input "residentMotions", "capability.motionSensor", title: "Motion sensors", multiple: true, required: false
            input "residentContacts", "capability.contactSensor", title: "Contact sensors", multiple: true, required: false
        }
        
        section("Delay Actions") {
            paragraph "Ignore intruder sensors while arming system and while residents are active for this duration"
            input "residentsQuietThreshold", "number", title: "Exit delay (minutes)", range: "1..5", required: false
        }
    }
}

def alarmsPage() {
    dynamicPage(name: "alarmsPage", title: "", install: false, uninstall: false) {
        section("Alarms and Actions") {
            /*def phrases = location.helloHome?.getPhrases()
            phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
            def showActions = true
            if (!phrases) {
                log.warn "No Routines found!!!"
            }*/

            input "alarms", "capability.alarm", title: "Turn on alarm(s)", multiple: true, required: false, submitOnChange: true
            if (alarms) {
                input "silent", "bool", title: "...only flash alarm lights", required: false
            }
            input "cameras", "capability.imageCapture", title: "Take pictures with cameras(s)", multiple: true, required: false
            input "lightson", "capability.switch", title: "Turn on these switch(s)", multiple: true, required: false
            //input "lightsFlashing", "capability.switch", title: "Flash these lights", multiple: true, required: false // Flashing doesn't work reliably with the z-wave/zigbee mesh yet
            //input "runPhrase", "enum", title: "Run routine", required: false, options: phrases, multiple: false
        }

        section("Delay Actions") {
            paragraph "Allow time to disarm before triggering intruder actions"
            input "seconds", "number", title: "Entry delay (seconds)", range: "30..300", required: false
        }
    }
}

def operatingPage() {
    dynamicPage(name: "operatingPage", title: "", install: false, uninstall: false) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section("Arming Configuration") {
            paragraph "Arm system when all configured conditions are met. If nothing is configured it be armed at all times."
            
            input "operatingModes", "mode", title: "Hub is in any of these modes", required: false, multiple: true // Mode is now optional when we have operating schedules
            //input "shmModes", "enum", title: "Classic SHM is in any of these states", multiple: true, required: false, options: ["away": "Armed Away", "stay": "Armed Stay"]
            input "operatingSwitchesOn", "capability.switch", title: "Any of these switches are on", multiple: true, required: false
            input "operatingLocksLocked", "capability.lock", title: "All of these locks are locked", multiple: true, required: false
            input "operatingPresenceArrive", "capability.presenceSensor", title: "Any of these people are present", multiple: true, required: false
            input "operatingPresenceLeave", "capability.presenceSensor", title: "All these people leave", multiple: true, required: false

            // 3 schedule options
            ('A'..'C').each { schedule ->
                def hrefParams = [
                    user: 1 as String,
                    schedule: schedule,
                    passed: true
                ]
                href(name: "schedule${schedule}", params: hrefParams, title: "Operating schedule ${schedule}", page: "scheduleCodesPage", description: (settings."userDayOfWeek${schedule}${1}" ? "${settings."userDayOfWeek${schedule}${1}"}: ${settings."userStartTime${schedule}${1}" ? (new Date(timeToday(settings."userStartTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""} - ${settings."userEndTime${schedule}${1}" ? (new Date(timeToday(settings."userEndTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""}" : "Not defined"), required: false)
            }
        }
    }
}

def notificationsPage() {
    dynamicPage(name: "notificationsPage", title: "", install: false, uninstall: false) {
        section("Notifications") {
            paragraph "Enable to get arming/disarming/countdown delay and action notifications"
            input "armNotifications", "bool", title: "Get detailed notifications", required: false
            input "keypads", "capability.lock", title: "Beep keypad for entry/exit delays", multiple: true, required: false
            input "textMessage", "text", title: "Intruder notification message", defaultValue: "Potential intruder detected", capitalization: "sentences", required: false
            input "audioMessage", "enum", title: "Intruder audio notification", description: "Speak", options: getAudioOptions(), required: false, submitOnChange: true
            if (audioMessage) {
                if (audioMessage == "Custom Audio URL") {
                    input "audioURL", "text", title: "...custom audio url", capitalization: "none", required: true
                }
            }
            input "audioDevices", "capability.audioNotification", title: "Speak/play notifications on", required: getAudioUri(audioMessage, audioURL)?.uri ? true : false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/Horn.png"
            if (audioDevices) {
                input "audioVolume", "number", title: "...at this volume level (optional)", description: "keep current", required: false, range: "1..100"
            }
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers by separating them with a '*'. E.g. 5551234567*+18747654321"
                input "sms", "phone", title: "Send SMS notification to", required: false, image: "https://www.rboyapps.com/images/Notifications.png"
                input "disableAllNotify", "bool", title: "Disable all push notifications", defaultValue: "false", required: false
            }
        }
    }
}

// Audio options
private getAudioOptions() {
    [
        "Bell 1",
        "Bell 2",
        "Dogs Barking",
        "Fire Alarm",
        "The mail has arrived",
        "A door opened",
        "There is motion",
        "Smartthings detected a flood",
        "Smartthings detected smoke",
        "Someone is arriving",
        "Piano",
        "Lightsaber",
        "Custom Audio URL",
        "Speak",
        "None",
        //"Custom message",
    ]
}

// Return a map of uri and duration for message type or converts a text message to an audio message with a uri and duration
private getAudioUri(target, message) {
    def sound = [:]
    switch (target) {
        case "Bell 1":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/bell1.mp3", duration: "10"]
            break
        case "Bell 2":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/bell2.mp3", duration: "10"]
            break
        case "Dogs Barking":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/dogs.mp3", duration: "10"]
            break
        case "Fire Alarm":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/alarm.mp3", duration: "17"]
            break
        case "The mail has arrived":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/the+mail+has+arrived.mp3", duration: "1"]
            break
        case "A door opened":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/a+door+opened.mp3", duration: "1"]
            break
        case "There is motion":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/there+is+motion.mp3", duration: "1"]
            break
        case "Smartthings detected a flood":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+a+flood.mp3", duration: "2"]
            break
        case "Smartthings detected smoke":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+smoke.mp3", duration: "1"]
            break
        case "Someone is arriving":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/someone+is+arriving.mp3", duration: "1"]
            break
        case "Piano":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/piano2.mp3", duration: "10"]
            break
        case "Lightsaber":
            sound = [uri: "http://s3.amazonaws.com/smartapp-media/sonos/lightsaber.mp3", duration: "10"]
            break
        case "Custom Audio URL":
            sound = [uri: message, duration: "0"]
            break
        case "Custom message":
            if (message) {
                sound = textToSpeech(message) // No translations at this time
            } else {
                log.warn "No text message provided"
            }
            break
        default:
            break
    }
}

private anySchedule() {
    def defined = false
    ('A'..'C').each { schedule ->
        if (settings."userDayOfWeek${schedule}${1}") {
            defined = true
        }
    }
    
    return defined
}

def scheduleCodesPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def user = params?.user ?: ""
    def schedule = params?.schedule ?: ""

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${schedule}", uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.debug "Schedule:$schedule, User:$i, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                description: "Not defined",
                required: false,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ]
        }
    }
}

def installed() {
	log.debug "INSTALLED with $settings"
    initialize()
}

def updated() {
	log.debug "UPDATED with $settings"
	initialize()
}

def initialize() {
    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades
    
    alarms?.off() // Reset any alarms
    resetSystem() // Reset the setup
    state.disarmNotification = false // Reset disarm notifications when system is reinitialized only
    checkUpdateCodeSchedule() // Initialize the code update checks incase it was erased

    runIn(1, checkArmDisarmEvent, [overwrite: true]) // Do it offline to avoid a timeout, it will enable if required
}

private checkUpdateCodeSchedule() {
    // Check for new versions of the code, initialize only in installed so it doesn't change everytime the app is saved
    def random = new Random()
    Integer randomHour = state.randomHour ?: random.nextInt(18-10) + 10
    Integer randomDayOfWeek = state.randomDayOfWeek ?: random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm   
    state.randomHour = randomHour // Save it
    state.randomDayOfWeek = randomDayOfWeek // Save it
}

// Reset setup and stop monitoring sensors
private resetSystem() {
    log.trace "Resetting system"
    
    if (atomicState.systemArmed || state.alarmActive) { // Only reset alarms if the system was active or in alarm (to avoid interfering with other apps)
        log.info "Resetting alarms"
        alarms?.off() // Reset any alarms
    }

    unsubscribe() // Stop monitoring all actions

    // Reset pending actions and system checks
    unschedule(startSystemArm)
    unschedule(exitCountdown)
    unschedule(entryCountdown)
    unschedule(startAlarmActions)
    unschedule(checkArmDisarmSchedule)
    
    // Reset all states
    atomicState.systemArmed = false
    atomicState.pendingAlarmAction = false
    state.alarmActive = false
	state.residentsAreUp = false
    state.armNotification = false
    state.armDisarmSchedule = false

    // Restore any beeping keypads to original mode
    restoreKeypadModes()

    // Only monitor operating conditions
    operatingModes ? subscribe(location, "mode", conditionChangeHandler) : ""
    //shmModes ? subscribe(location, "alarmSystemStatus" , conditionChangeHandler) : ""
    operatingSwitchesOn ? subscribe(operatingSwitchesOn, "switch", conditionChangeHandler) : ""
    operatingLocksLocked ? subscribe(operatingLocksLocked, "lock", conditionChangeHandler) : ""
    operatingPresenceArrive ? subscribe(operatingPresenceArrive, "presence", conditionChangeHandler) : ""
    operatingPresenceLeave ? subscribe(operatingPresenceLeave, "presence", conditionChangeHandler) : ""
    subscribe(app, appTouch)
}

// Start Monitoring all sensors
private monitorSensors() {
    log.trace "Started monitoring sensors"
    
    atomicState.systemArmed = true // We're armed the system
    
    // Stop any beeping keypads and restore them
    restoreKeypadModes()   

    intrusionMotions ? subscribe(intrusionMotions, "motion", intruderMotion) : ""
    intrusionContacts? subscribe(intrusionContacts, "contact", contact) : ""
    intrusionLocks ? subscribe(intrusionLocks, "lock", door) : ""
    alarms ? subscribe(alarms, "alarm", alarm) : ""
    tamperDevices ? subscribe(tamperDevices, "tamper", tamper) : ""
    panicSwitches ? subscribe(panicSwitches, "switch", panic) : ""
    panicButtons ? subscribe(panicButtons, "button", panic) : ""
    vibrationDevices ? subscribe(vibrationDevices, "acceleration", vibration) : ""
}

def conditionChangeHandler(evt) {
    log.trace "Condition change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"
    checkArmDisarmEvent(evt)
}

def appTouch(evt) {
    log.info "Resetting alarms and reinitializing system"
	initialize()
}

def panic(evt) {
    if ((evt.value == "on") || (evt.value == "held") || (evt.value == "pushed")) {
        log.trace "Panic switch/button $evt.displayName activated, starting intruder alarm sequence"
        startAlarmSequence(evt)
    }    
}

def vibration(evt) {
    if (evt.value == "active") {
		log.trace "Vibration $evt.displayName by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}    
}

def tamper(evt) {
    if (evt.value == "detected") {
		log.trace "Tamper $evt.displayName by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}    
}

def intruderMotion(evt) {
	if (evt.value == "active") {
		log.trace "$evt.displayName motion by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def contact(evt) {
	if (evt.value == "open") {
		log.trace "Contact $evt.displayName opened by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def door(evt) {
    if (evt.value == "unlocked") {
		log.trace "Door $evt.displayName unlocked by potential intruder, residentsAreUp: $state.residentsAreUp"
        if (!state.residentsAreUp) {
            if (residentsHaveBeenQuiet()) {
                startAlarmSequence(evt)
            }
        } else {
            log.trace "Residents are up, ignoring"
        }
    }
}

def alarm(evt) {
	log.trace "Alarm $evt.name: $evt.value"
	if (evt.value == "off") { // If any one alarm is turned off, turn off the rest
		alarms?.off()
		state.alarmActive = false

        def msg = "$evt.displayName: Alarm turned off, turning off all other alarms"
        log.debug msg
        if (armNotifications) {
            sendNotifications(msg) // Do this in the end as it may timeout
        }
    }
}

private residentsHaveBeenQuiet() {
	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	def result = true
	def t0 = new Date(now() - threshold)
	
    for (sensor in residentMotions) {
		def recentStates = sensor.statesSince("motion", t0)
		if (recentStates.find{it.value == "active"}) {
			result = false
			break
		}
	}
	
    for (sensor in residentContacts) {
		def recentStates = sensor.statesSince("contact", t0)
		if (recentStates.find{it.value == "open"}) {
			result = false
			break
		}
	}
    
	log.trace "residentsHaveBeenQuiet: $result"
	result
}

def setKeypadDelay(data) {
    def supportedKeypads = keypads?.findAll{ it.hasAttribute("armMode") } // Get all supported keypads
    if (supportedKeypads) {
        switch (data?.type) {
            case "exit":
                state.lastKeypadModes = [:]
                supportedKeypads.each { keypad -> state.lastKeypadModes[keypad.id] = keypad.currentValue("armMode") as String } // Save the last keypad states so we can restore them later
                supportedKeypads*.setExitDelay(residentsQuietThreshold * 60) // Start exit delay beeping
                log.debug "Starting exit delay beeping for $supportedKeypads, saved states ${state.lastKeypadModes}"
            	break
            case "entry":
                state.lastKeypadModes = [:]
                supportedKeypads.each { keypad -> state.lastKeypadModes[keypad.id] = keypad.currentValue("armMode") as String } // Save the last keypad states so we can restore them later
                supportedKeypads*.setEntryDelay(seconds) // Start entry delay beeping
                log.debug "Starting entry delay beeping for $supportedKeypads, saved states ${state.lastKeypadModes}"
                break
            default:
            	log.warn "Unknown keypad beeping mode $data"
                break
        }
    } else {
        log.warn "No keypads selected, cannot activate beeping mode: $data"
    }
}

// Restore the original keypad modes
private restoreKeypadModes() {
    def supportedKeypads = keypads?.findAll{ it.hasAttribute("armMode") } // Get all supported keypads
    
    log.trace "Restoring $supportedKeypads, last state: ${state.lastKeypadModes}"
    
    if (supportedKeypads) {
        unschedule(setKeypadDelay) // Cancel any pending keypad entry/exit timers
        if (state.lastKeypadModes) {
            if (false && shmModes) { // If we are using SHM Dashboard then sync the keypad with the dashboard mode
                def shmMode = location.currentState("alarmSystemStatus")?.value
                log.debug "Syncing ${supportedKeypads} to SHM mode ${shmMode}"
                switch(shmMode) {
                    case "away":
                        supportedKeypads*.setArmedAway()
                        break
                    case "stay":
                        supportedKeypads*.setArmedStay()
                        break
                    case "off":
                        supportedKeypads*.setDisarmed()
                        break
                    default:
                        log.warn "Unknown SHM mode: ${shmMode}"
                        break
                }
            } else { // Otherwise set the keypad to current mode of app
                if (atomicState.systemArmed) { // If we are armed set to the last known armed state
                    supportedKeypads.each { keypad ->
                        switch (state.lastKeypadModes[keypad.id]) { // Restore the last keypad states
                            case "armedAway":
                                log.debug "Setting $keypad to armedAway"
                                keypad.setArmedAway()
                                break                    
                            case "armedStay":
                                log.debug "Setting $keypad to armedStay"
                                keypad.setArmedStay()
                                break                    
                            case "armedNight":
                                log.debug "Setting $keypad to armedNight"
                                keypad.setArmedNight()
                                break
                            case "disarmed": // We shouldn't be in disarmed state here, if so then reset it to armedAway
                            default:
                                log.warn "Unknown $keypad last state: ${state.lastKeypadModes[keypad.id]}, setting $keypad to armedAway"
                                keypad.setArmedAway()
	                            break
                        }
                    }
                } else {
                    log.debug "Resetting ${supportedKeypads} to Disarmed"
                    supportedKeypads*.setDisarmed()
                }
            }
            state.lastKeypadModes = [:] // We're done restoring it, reset it
        }
    }
}

// Check if system needs to be armed or disarmed based on conditions (not schedule) (called on conditions change and during initialization)
// If we're disarming the system here (Reset) then we don't need to worry about rearming it on schedule since the arming conditions aren't met, then they change this will be retriggered
def checkArmDisarmEvent(evt = null) {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "NOTE: ${app.label} detected a code upgrade. Reinitializing, please open the app and re-validate your settings"
        runIn(1, initialize, [overwrite: true])
        log.warn msg
        //sendPush(msg) // Do this in the end as it may timeout
        return
    }
    
    if (!checkDisarmConditions()) {
        log.trace "Checking rearming schedule for event: ${evt?.name ?: "initialize app"}"
        checkArmDisarmSchedule()
    }
}

// Checks and disarms system if needed and return true is system was disarmed
private checkDisarmConditions() {
    def msg = ""
    
    if (operatingModes && !operatingModes.any { location.mode == it }) { // If aren't in a selected operating mode
        log.trace "Resetting rearm since new mode ${location.mode} is not in operating modes ${operatingModes}"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " for ${location.mode} mode"
            }
        }
    } else if (false && shmModes && !shmModes.any { location.currentState("alarmSystemStatus")?.value == it }) { // If aren't in a selected SHM mode
        log.trace "Resetting rearm since SHM mode ${location.currentState("alarmSystemStatus")?.value} is not in operating modes ${shmModes}"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " for SHM mode ${location.currentState("alarmSystemStatus")?.value}"
            }
        }
    } else if (operatingSwitchesOn && operatingSwitchesOn.any { it.currentValue("switch") == "off" }) { // If any of the switches are off
        def dev = operatingSwitchesOn.find { it.currentValue("switch") == "off" }
        log.trace "Resetting rearm since switch ${dev} is off"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " since ${dev} is off"
            }
        }
    } else if (operatingLocksLocked && operatingLocksLocked.any { it.currentValue("lock") != "locked" }) { // If any of the locks are not locked (unknown, unlocked etc)
        def dev = operatingLocksLocked.find { it.currentValue("lock") != "locked" }
        log.trace "Resetting rearm since lock ${dev} is not locked"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " since ${dev} is not locked"
            }
        }
    } else if (operatingPresenceArrive && operatingPresenceArrive.any { it.currentValue("presence") == "not present" }) { // If any of the people are away
        def dev = operatingPresenceArrive.find { it.currentValue("presence") == "not present" }
        log.trace "Resetting rearm since person ${dev} is away"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " since ${dev} is away"
            }
        }
    } else if (operatingPresenceLeave && operatingPresenceLeave.any { it.currentValue("presence") == "present" }) { // If any of the people are present
        def dev = operatingPresenceLeave.find { it.currentValue("presence") == "present" }
        log.trace "Resetting rearm since person ${dev} is present"
        resetSystem() // Reset the system
        if (!state.disarmNotification) {
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " since ${dev} is present"
            }
        }
    } else { // The arming conditions are met, now check if the scheduling conditions are met
    	return false
    }
    
    // Check if we have any pending messages to send
    if (msg) {
        log.info msg
        if (armNotifications) {
            sendNotifications(msg) // Do this in the end as it may timeout
        }
    }
    
    return true
}

// Check if we inside or outside the schedule and then arm or disarm appropriately
def checkArmDisarmSchedule() {
    def msg = ""
    
    if (anySchedule() && !('A'..'C').any { schedule -> checkSchedule(1, schedule) }) { // Check if we are outside operating Schedule
        //log.trace "We are outside the operating schedule, disarmed"
        if (!state.disarmNotification) {
            resetSystem() // Reset the system
            state.disarmNotification = true // Don't keep announcing when switching between disarmed modes
            msg = "Disarming ${app.label}"
            if (armNotifications) {
                msg += " since the operating schedule has ended"
            }
        }
    } else { // If we have no schedules defined, then we're within the operating schedule
        //log.trace "We are within the operating schedule, armed"
        if (!atomicState.systemArmed) { // If we are aren't armed yet, lets start arming the system
            log.debug "Starting arming for ${app.label}"
            runIn(0, startSystemArm, [overwrite: true, data: [lastArmRequest: now()]]) // Arm it offline so it only runs once
        }
    }

    // Schedule this after resetting system or activating arming
    if (!state.armDisarmSchedule) { // Setup check arm/disram schedule
        log.debug "Starting arm/disarm schedule check"
        schedule("* 0/${checkInterval} * * * ?", checkArmDisarmSchedule) // Check every checkInterval minute when system needs to be rearmed
        state.armDisarmSchedule = true // We've setup a schedule
    }

    // Check if we have any pending messages to send
    if (msg) {
        log.info msg
        if (armNotifications) {
            sendNotifications(msg) // Do this in the end as it may timeout
        }
    }
}

// Start arming the system
def startSystemArm(evt) {
    //log.trace "Start system alarm: ${evt?.inspect()}"
    
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    if (atomicState.systemArmed) { // We should not get here ideally
        log.warn "System already armed, not arming!"
        return // We're done
    }
    
	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	// check last intruder motion
	def lastArmRequest = state.armNotification ? state.lastArmRequest : evt.lastArmRequest // If we already have an arm pending, let piggy back on it and not start a new one
	if (lastArmRequest != null) {
        log.trace "Last Arm Request: ${(new Date(lastArmRequest ?: 0)).format("EEE MMM dd HH:mm:ss", timeZone)}\nTime since last arm request: ${(now() - lastArmRequest)/(1000)} seconds, threshold is ${threshold/1000} seconds"
        state.disarmNotification = false // We're in armed mode
		if (now() > (lastArmRequest + threshold)) { // We're ready to arm
            def msg = "Arming ${app.label}"
            state.residentsAreUp = false
            state.armNotification = false
            state.alarmActive = false
            unschedule(exitCountdown)
            unschedule(startSystemArm)
            monitorSensors() // Start monitoring sensors
            log.info msg
            if (armNotifications) {
                sendNotifications(msg) // Do this in the end as it may timeout
            }
		} else { // Arming countdown (Exit Countdown)
			state.residentsAreUp = true // We aren't ready to arm the system yet
            def timeToArm = (((lastArmRequest + threshold) - now())/(60*1000)) as Float
            log.trace "Time to arm: $timeToArm minutes"
            if (!state.armNotification) {
                state.lastArmRequest = evt.lastArmRequest // Save it
                state.armNotification = true // We've sent a notification
                def supportedKeypads = keypads?.findAll{ it.hasAttribute("armMode") } // Get all supported keypads
                if (supportedKeypads) {
                    log.trace "Starting exit delay beeping for $supportedKeypads in $keypadBeepDelay seconds"
                    runIn(keypadBeepDelay, setKeypadDelay, [overwrite: true, data: [type: "exit"]])
                }
                def msg = "Arming ${app.label} in about ${timeToArm.round()} minutes"
                log.debug msg
                if (armNotifications) { // Trigger a countdown
                    runIn(countdownInterval, exitCountdown, [overwrite: true, data: evt]) // Start the countdown every X seconds
                    sendNotifications(msg) // Do this in the end as it can timeout
                } else { // Just schedule a check again
                    runIn(((timeToArm * 60) + 1) as Integer, startSystemArm, [overwrite: true, data: evt]) // Trigger check timetoArm
                }
            } else { // Just schedule a check again for remainder time
                runIn(((timeToArm * 60) + 1) as Integer, startSystemArm, [overwrite: true, data: evt]) // Trigger check timetoArm
            }
        }
	} else {
		log.error "lastArmRequest was null, unable to arm system"
	}	
}

// Announce the Exit Delay countdown
def exitCountdown(evt) {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	def lastArmRequest = evt.lastArmRequest
    def timeToArm = (((lastArmRequest + threshold) - now())/(1000) + 1) as Integer // Remaining time in seconds, round up
    log.trace "Exit countdown, time to arm: $timeToArm seconds\nlastArmRequest: ${(new Date(lastArmRequest ?: 0)).format("EEE MMM dd HH:mm:ss", timeZone)}\nthreshold: ${threshold/1000} seconds"

    if (timeToArm > countdownInterval) { // We have time left to arm
        runIn(countdownInterval, exitCountdown, [overwrite: true, data: evt]) // Start the countdown every X seconds
        def msg = "Arming ${app.label} in about ${timeToArm} seconds"
        if (armNotifications) {
            log.trace msg
            sendNotifications(msg) // Do this in the end as it can timeout
        }
    } else if (timeToArm > 0) { // Intermediary time, schedule the trigger directly
        log.trace "Arming system in $timeToArm seconds"
        runIn(timeToArm, startSystemArm, [overwrite: true, data: evt]) // Start the countdown every X seconds
    } else { // We're past, lets trigger it
        runIn(0, startSystemArm, [overwrite: true, data: evt]) // Do it offline so that it removes any pending schedules
    }
}

// Announce the Entry Delay countdown
def entryCountdown(evt) {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def timeToArm = ((evt.trigger - now())/(1000) + 1) as Integer // Remaining time in seconds, round up
    log.trace "Entry countdown, time to alarm: $timeToArm seconds, trigger: ${(new Date(evt.trigger ?: 0)).format("EEE MMM dd HH:mm:ss", timeZone)}"

    if (timeToArm > countdownInterval) { // We have time left to trigger
        runIn(countdownInterval, entryCountdown, [overwrite: true, data: evt])
        def msg = "$evt.displayName: starting intruder actions in ${timeToArm} seconds"
        if (armNotifications) {
            log.trace msg
            sendNotifications(msg) // Do this in the end as it can timeout
        }
    } else if (timeToArm > 0) {
        log.trace "Triggering alarms in $timeToArm seconds"
        runIn(timeToArm, startAlarmActions, [overwrite: true, data: evt])
    } else {
        startAlarmActions(evt) // We're past, lets trigger it
    }
}

private startAlarmSequence(evt) {
    //log.trace "StartAlarmSequence: $evt.displayName"
    
    // Check if we are within any of the operating schedules
    if (checkDisarmConditions()) { // Check if we are outside operating Schedule    
        log.warn "System was armed when it supposed to be disarmed, disarming and ignoring event"
        return
    }

    // Check for a Entry Delay
    if (seconds) {
        if (!atomicState.pendingAlarmAction) { // Don't reset each time a sensor is set off until we have completed the action
            atomicState.pendingAlarmAction = true
            if (armNotifications && (seconds > countdownInterval)) { // We have time left to trigger and we're asked for notifications
                runIn(countdownInterval, entryCountdown, [overwrite: true, data: [displayName: evt.displayName, trigger: (now() + (seconds * 1000))]])
            } else {
                runIn(seconds, startAlarmActions, [overwrite: true, data: [displayName: evt.displayName, trigger: (now() + (seconds * 1000))]])
            }
            def supportedKeypads = keypads?.findAll{ it.hasAttribute("armMode") } // Get all supported keypads
            if (supportedKeypads) {
                runIn(0, setKeypadDelay, [overwrite: true, data: [type: "entry"]]) // No delay required here but use runIn so it overwrite any pending schedules
            }
            def msg = "$evt.displayName: starting intruder actions in $seconds seconds"
            log.trace msg
            // Do this in the end because it can timeout
            if (armNotifications) {
                sendNotifications(msg)
            }
        } else {
            log.debug "$evt.displayName: Intruder delayed actions already active"
        }
    } else {
        startAlarmActions(evt)
    }
}

// Run the alarm actions
def startAlarmActions(evt) {
    log.info "Starting intruder actions sequence: ${evt?.displayName}"
    
    atomicState.pendingAlarmAction = false // delayed actions are complete, reset it so we can capture the next action
    
    // Only set this if we have Alarms defined because it will be reset when the alarms are turned off, without alarms start sequence every time
    if (alarms) {
        state.alarmActive = true
        soundSiren()
    }

    /*if (runPhrase) {
        log.debug "Running routine $runPhrase"
        location.helloHome.execute(runPhrase)
    }*/

    if (lightsFlashing) {
        log.debug "Flashing lights"
        runIn(1, continueFlashing, [overwrite: true]) // do it offline to avoid timeout since it's a heavy activity
    }

    if (lightson) {
        log.debug "Turning on lights $lightson"
        lightson?.on()
        lightson?.each { lighton -> 
            if (lighton?.hasCommand("setLevel")) {
                lighton?.setLevel(100) // If it is a dimmer set it to 100%
            }
        }
    }

    if (cameras) {
        log.debug "Taking pictures with $cameras"
        cameras?.take()
    }

    // Stop any beeping keypads and restore them
    restoreKeypadModes()
    
    // Do this in the end because it can timeout
    def uri = getAudioUri(audioMessage, audioURL)?.uri
    log.trace "Custom Audio URL: $uri"
    sendNotifications(textMessage ? "$evt.displayName: $textMessage" : "$evt.displayName: Potential intruder detected", uri)
}

def soundSiren() {
	if (state.alarmActive) {
        if (silent) {
            log.debug "Silent alarm only"
            alarms?.strobe()
        } else {
            log.debug "Sounding siren"
            alarms?.both()
        }
	} else {
		log.debug "Intruder notification reset, alarm activation aborted"
	}
}

def continueFlashing() {
    // Flash 10 times
    state.flashingCount = (state.flashingCount ?: 0) + 1
    if (state.flashingCount <= 10) {
        flashLights(1000)
        runIn(2, continueFlashing, [overwrite: true]) // After 2 seconds because we're turning off after 1 second
        log.trace "Flashing lights counter: $state.flashingCount"
    } else {
        state.flashingCount = 0 // Reset it
        log.trace "Finished flashing"
    }
}

private flashLights(long delay) {
    lightsFlashing?.on()
    lightsFlashing?.off([delay: delay])
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}" - optional
// settings."userEndTime${x}${i}" - optional
// settings."userDayOfWeek${x}${i}" - required
private checkSchedule(def i, def x) {
    log.trace "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.trace "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" && settings."userEndTime${x}${i}") {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.trace "Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}"

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug "Outside operating time schedule"
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.trace "Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}"

    if(!settings."userDayOfWeek${x}${i}") {
        log.debug "Day of week not specified for operating schedule $x for user $i"
        return false
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.replaceAll("[;,#]", "*").split("\\*") // Some users accidentally use ;,# instead of * and ST can't handle *,#+ in the number except for + at the beginning
        for (phone in phones) {
            try {
                sendSms(phone, message)
            } catch (Exception e) {
                sendPush "Invalid phone number $phone"
            }
        }
    }
}

private void sendNotifications(message, uri = null) {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (!disableAllNotify) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }

    if (uri && audioDevices) { // Play custom audio uri
        if (audioVolume) { // Only set volume if defined as it also resumes playback
            audioDevices*.playTrackAndResume(uri, audioVolume)
        } else {
            audioDevices*.playTrack(uri)
        }
    } else if (audioDevices) { // Audio notifications
        audioDevices?.each { audioDevice -> // Play audio notifications
            if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTextAndResume(message, audioVolume)
                } else {
                    audioDevice.playText(message)
                }
            } else {
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
                } else {
                    audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
                }
            }
        }
    }
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "Intruder Alert with Actions",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt = null) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Intruder Alert with Alarms, Lights and Camera Pictures"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = 
                [ intrusionMotions,
                 intrusionContacts,
                 intrusionLocks,
                 tamperDevices,
                 panicSwitches,
                 panicButtons,
                 residentMotions,
                 residentContacts,
                 alarms,
                 cameras,
                 lightson,
                 lightsFlashing ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE