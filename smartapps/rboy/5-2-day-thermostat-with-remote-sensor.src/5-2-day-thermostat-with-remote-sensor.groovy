/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() { return "03.12.01" }

/**
 * 5-2 Day Thermostat with Remote Sensor
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 *
 * 2020-07-29 - (v03.12.01) New app/platform improvements
 * 2020-06-17 - (v03.11.04) Fix for fan modes being continually set
 * 2020-05-14 - (v03.11.03) Initialize setpoint after changing mode due to external temp
 * 2020-05-04 - (v03.11.02) Try to detect platform outage and prevent code upgrade spam notifications
 * 2020-02-05 - (v03.11.01) Add limits for temperature inputs
 * 2020-01-30 - (v03.11.00) Add option for timeout for door open/close sensor (default 1 minute)
 * 2020-01-20 - (v03.10.05) Update icons for broken ST Android app 2.18
 * 2019-12-30 - (v03.10.04) Fixed an issue with using a global remote temperature sensor
 * 2019-12-12 - (v03.10.03) Add swing temp range
 * 2019-08-30 - (v03.10.02) Reset temp hold on target setpoint resume for non remote sensor and with extreme setpoints with remote sensor
 * 2019-08-19 - (v03.10.00) EVery 5 minutes check to see if thermostat setpoint were not set due to communication failure
 * 2019-07-25 - (v03.09.06) Update thermostat setpoint for remote temperature sensors to be compatible with trane thermostat limits
 * 2019-05-01 - (v03.09.05) Clarify that temporary hold applies to all thermostat settings
 * 2019-02-04 - (v03.09.04) Enforce temperature settings unless Temp Hold is enabled to avoid accidental changes
 * 2019-01-12 - (v03.09.03) Use the original API to set fanMode for thermostat for better compliance with legacy DTH's
 * 2018-12-21 - (v03.09.02) Update max/min cooling/heating setpoints to be compatible with the Pearl Centralite thermostat
 * 2018-11-16 - (v03.09.00) Heat and cool settings are now optional, if not specified it will skip any adjustments for that schedule
 * 2018-09-03 - (v03.08.03) Fix for using incorrect setting between midnight Sunday and Monday
 * 2018-08-06 - (v03.08.02) Added option to save battery by reducing communications, disable if thermostat has losing commands in the mesh
 * 2018-07-30 - (v03.08.01) Added support for open door/window sensors to disable HVAC/appliances when opened
 * 2018-07-16 - (v03.07.00) Allow decimal temperature settings for thermostats that support it
 * 2018-03-09 - (v03.06.00) Added option to enable/disable temporary hold when using a remote temperature sensor
 * 2018-01-31 - (v03.05.03) Fix for temporary hold when thermostat reports decimal temperatures
 * 2018-01-04 - (v03.05.02) Don't initialize if we aren't in the selected mode
 * 2017-09-09 - (v03.05.01) Updated min temp to 60F for better GoControl thermostat compatibility
 * 2017-09-05 - (v03.05.00) Updated min/max thresholds for remote sensors to be compatible with new ST thermostat device handler (deadZones)
 * 2017-07-07 - (v03.04.02) Added option to manually reinitiate thermostat by clicking the "Arrow" button
 * 2017-07-07 - (v03.04.01) Added support for temporary hold mode even when not using a remote temperature sensor and added option to manually reinitiate thermostat by clicking the "Arrow" button
 * 2017-03-14 - (v3.4.0) Added support for using heating and cooling appliances instead of a thermostat
 * 2017-02-01 - (v3.3.1) Added ability for temporary hold when using remote temperature sensors
 * 2016-11-02 - Added ability to select multiple remote temperature sensors and average them out and ability to check for DH and SA updates and notify user
 * 2016-10-09 - Tweak the threshold setting to help compensate for sensors which update with lower accuracy
 * 2016-09-02 - Made fan setting optional
 * 2016-08-30 - Added support for remote temp sensors for each schedule and also ability to set fan mode for each schedule, optimize settings to reduce impact on battery
 * 2016-06-13 - Choosing thermostats is optional so that it can be temporatily disabled
 * 2016-05-24 - Used new scheduling mechanisms since runOnce keeps getting dropped by the scheduler
 * 2016-05-17 - Fix for potential app dying due to platform timeout
 * 2016-05-15 - Notify use if timezone/location is missing in setup
 * 2016-02-08 - Modes are now controlled by ST platform, app will only operate in designated modes (including turning off)
 * 2016-02-07 - Set temp only if it needs to be changed to save thermostat battery
 * 2016-01-28 - Added ability to rename app
 * 2016-01-28 - Fixed an issue where the modes weren't functioning properly
 * 2016-01-11 - Fixed a bug introduced with remote temperature sensors feature which caused any manual overrides on the thermostat to be overwritten by the app before the end of the current schedule
 * 2016-01-04 - Added support for using a remote temperature sensor to control the thermostat
 * 2016-01-04 - Added hideable sections to make it more readable
 * 2016-01-04 - Added external events to kick start timers to compensate for buggy platform timers dying
 * 2015-10-03 - Fixed an issue with selecting multiple thermostats and for recent platform changes
 * 2015-05-17 - Added ability to select mutiple thermostats simultaneously
 * 2015-02-11 - Fixed issue with fan mode
*/
definition(
    name: "5-2 Day Thermostat with Remote Sensor",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Weekday and Weekend Thermostat with Remote Temperature Sensor Option",
    category: "Green Living",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@2x.png",
    iconX3Url: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving@3x.png")

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
    page(name: "scheduleWeek")
}

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "5-2 Day Thermostat with Remote Sensor v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "5-2 Day Thermostat with Remote Sensor v${clientVersion()}", nextPage: "scheduleWeek", install: false, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section("Choose temperature control devices") {
            if (!(coolers || heaters)) {
                paragraph "Select thermostat to control temperature"
                input "thermostats", "capability.thermostat", title: "Thermostat(s)", required: false, multiple:true, submitOnChange: true
                input name: "allowTempHold", type: "bool", title: "Allow thermostat temporary hold", description: "Allow the user to manually override the thermostat temperature setting until the next scheduled change", required: false, submitOnChange: false
            }
            if (!(coolers || heaters || thermostats)) {
                paragraph "** OR **"
            }
            if (!thermostats) {
                paragraph "Select heating and cooling applicances to control temperature"
                input "coolers", "capability.switch", title: "Use these coolers(s)", required: false, multiple:true, submitOnChange: true
                input "heaters", "capability.switch", title: "Use these heaters(s)", required: false, multiple:true, submitOnChange: true
            }
            paragraph ""
            paragraph "Shutdown ${thermostats ? "thermostat" : "applicances"} if any of these doors/windows are opened"
            input "openDoors", "capability.contactSensor", title: "Door/window sensor(s)", required: false, multiple:true, submitOnChange: false
        }

        section("Use remote temperature sensor to control thermostat (optional)", hidden: false, hideable: false) {
            paragraph "You can use a remote sensor instead of the built in thermostat temperature sensor to monitor the temperature. You can also configure the app to use a separate remote sensor for each schedule or use a single sensor for all schedules"
            if (!customRemoteTempSensor) {
                if ((remoteTemperatureSensor*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor", "capability.temperatureMeasurement", title: "Remote temperature sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            input "customRemoteTempSensor", "bool", title: "Select separate remote sensor for each schedule", required: false, submitOnChange: true
            input "threshold", "decimal", title: "Temperature swing (precision)", defaultValue: "1.0", required: true, range: "0.4..5.0" // TODO: watch range, causes Android 2.0.7 to crash
        }

        section("Operating Modes (optional)") {
            mode title: "Enable temperature control only when in this mode(s)", required: false, multiple: true
        }
        
        if (!(coolers || heaters)) {
            section("Switch HVAC mode (auto to cool/heat) based on the outside temperature (optional)", hidden: (outsideTemperatureSensor ? false : true), hideable: true) {
                input "outsideTemperatureSensor", "capability.temperatureMeasurement", title: "Outside sensor", required: false, multiple:false, submitOnChange: true
                input "temperatureH", "number", title: "Switch to heating temperature", required: (outsideTemperatureSensor ? true : false), description: "Temperature below which switch to heat mode"
                input "temperatureC", "number", title: "Switch to cooling temperature", required: (outsideTemperatureSensor ? true : false), description: "Temperature above which switch to cool mode"
            }
        }
        
        section("Advanced Settings", hidden: true, hideable: true) {
            input "doorOpenInterval", "number", title: "Door/Window sensor open threshold (minutes)", description: "How long should it be open before turning off system", defaultValue: 1, range: "1..60", required: true
            input "batterySaver", "bool", title: "Save battery by skipping verification", description: "Disable this if schedules are not operating reliably", required: false, submitOnChange: false
        }
        
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
        }

        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }
    }
}

def scheduleWeek() {
    dynamicPage(name: "scheduleWeek", title: "Configure Thermostat Schedule", install: true, uninstall: true) {
        section("Monday to Friday Schedule", hidden: false, hideable: true) {
            input "time1", "time", title: "Wake Time", required: true
            input "tempHSetpoint1", "decimal", title: "Wake Heat Temp", range: "0..100", required: false
            input "tempCSetpoint1", "decimal", title: "Wake Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode1", "enum", title: "Wake Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor1*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor1", "capability.temperatureMeasurement", title: "Wake Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time2", "time", title: "Leave Time", required: true
            input "tempHSetpoint2", "decimal", title: "Leave Heat Temp", range: "0..100", required: false
            input "tempCSetpoint2", "decimal", title: "Leave Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode2", "enum", title: "Leave Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor2*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor2", "capability.temperatureMeasurement", title: "Leave Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time3", "time", title: "Return Time", required: true
            input "tempHSetpoint3", "decimal", title: "Return Heat Temp", range: "0..100", required: false
            input "tempCSetpoint3", "decimal", title: "Return Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode3", "enum", title: "Return Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor3*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor3", "capability.temperatureMeasurement", title: "Return Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time4", "time", title: "Sleep Time", required: true
            input "tempHSetpoint4", "decimal", title: "Sleep Heat Temp", range: "0..100", required: false
            input "tempCSetpoint4", "decimal", title: "Sleep Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode4", "enum", title: "Sleep Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor4*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor4", "capability.temperatureMeasurement", title: "Sleep Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
        }
        section("Saturday and Sunday Schedule", hidden: false, hideable: true) {
            input "time11", "time", title: "Wake Time", required: true
            input "tempHSetpoint11", "decimal", title: "Wake Heat Temp", range: "0..100", required: false
            input "tempCSetpoint11", "decimal", title: "Wake Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode11", "enum", title: "Wake Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor11*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor11", "capability.temperatureMeasurement", title: "Wake Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time21", "time", title: "Leave Time", required: true
            input "tempHSetpoint12", "decimal", title: "Leave Heat Temp", range: "0..100", required: false
            input "tempCSetpoint12", "decimal", title: "Leave Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode12", "enum", title: "Leave Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor12*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor12", "capability.temperatureMeasurement", title: "Leave Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time31", "time", title: "Return Time", required: true
            input "tempHSetpoint13", "decimal", title: "Return Heat Temp", range: "0..100", required: false
            input "tempCSetpoint13", "decimal", title: "Return Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode13", "enum", title: "Return Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor13*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor13", "capability.temperatureMeasurement", title: "Return Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
            paragraph ""
            input "time41", "time", title: "Sleep Time", required: true
            input "tempHSetpoint14", "decimal", title: "Sleep Heat Temp", range: "0..100", required: false
            input "tempCSetpoint14", "decimal", title: "Sleep Cool Temp", range: "0..100", required: false
            if (!(coolers || heaters)) {
                input "fanMode14", "enum", title: "Sleep Fan Mode", required: false, multiple:false, options: fanModes()
            }
            if (customRemoteTempSensor) {
                if ((remoteTemperatureSensor14*.currentTemperature)?.count { it } > 1) {
                    paragraph title: "You have selected multiple remote sensors, the average temperature across the sensors will be used", required: true, ""
                }
                input "remoteTemperatureSensor14", "capability.temperatureMeasurement", title: "Sleep Remote Temp Sensor", required: ((coolers || heaters) ? true : false), multiple: true, submitOnChange: true
            }
        }
    }
}

// Globals
private getMIN_HEAT_TEMP_F() { 55 } // Keep a deadband diff between heat and cool
private getMAX_HEAT_TEMP_F() { 84 }
private getMIN_COOL_TEMP_F() { 60 }
private getMAX_COOL_TEMP_F() { 86 }
private getMIN_HEAT_TEMP_C() { 12 }
private getMAX_HEAT_TEMP_C() { 28 }
private getMIN_COOL_TEMP_C() { 15 }
private getMAX_COOL_TEMP_C() { 30 }

def fanModes() {
    return ["Auto", "On", "Circulate"]
}

def installed()
{
    log.debug "Installed"

    subscribeToEvents()
}

def updated()
{
    log.debug "Updated"

    subscribeToEvents()
}

def subscribeToEvents() {
    state.clientVersion = clientVersion()
    
    unsubscribe()
    unschedule()

    subscribe(location, "mode", modeChangeHandler) // Reinitailize the temperature and timers when the correct mode is enabled (since we don't use dynamic preferences, the timers won't fire and temp won't change in a mode not selected, so we need to reset it all on the correct mode)
    subscribe(outsideTemperatureSensor, "temperature", outsideTemperatureHandler) // Handle changes to thermostat operating mode based on external temperature
    if (customRemoteTempSensor) {
        (1..4).each {
            subscribe(settings."remoteTemperatureSensor${it}", "temperature", remoteChangeHandler) // Handle changes in remote temperature sensor and readjust thermostat AND also kick start timer (dual role)
            subscribe(settings."remoteTemperatureSensor1${it}", "temperature", remoteChangeHandler) // Handle changes in remote temperature sensor and readjust thermostat AND also kick start timer (dual role)
        }
    } else {
        subscribe(remoteTemperatureSensor, "temperature", remoteChangeHandler) // Handle changes in remote temperature sensor and readjust thermostat AND also kick start timer (dual role)
    }
    subscribe(thermostats, "heatingSetpoint", thermostatSetTempHandler) // Handle changes in manual thermostat heating setpoint temperature changes for Hold mode
    subscribe(thermostats, "coolingSetpoint", thermostatSetTempHandler) // Handle changes in manual thermostat cooling setpoint temperature changes for Hold mode
    subscribe(openDoors, "contact", doorContactHandler) // Handle open/closed door/windows contact sensors

    // Kick start timers incase it died
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers
    runEvery5Minutes(heartBeat) // Since we have a heartbeat we don't need kick start timers

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    runIn(1, initialize) // Schedule this to that it won't execute if we aren't in the correct mode
}

// Heartbeat to check if the app timed out while trying to set the temp and died
def heartBeat() {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and re-validate your settings"
        log.warn msg
        runIn(1, subscribeToEvents) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        sendPush(msg) // Do this in the end as it may timeout
        return
    }

    log.trace "Thermostat heartbeat called, Checking thermostat state"

    thermostats.each { thermostat ->
        if (atomicState."holdTemp${thermostat}") {  // If we are on hold temp mode for this thermostat
            log.trace "Thermostat ${thermostat} is in hold temperature mode, not making any changes to thermostat"    
        } else {
            changeTemp(setSchedule(false), false) // Since this is done periodically don't force set the schedule or setpoints, just check for disconnects
        }
    }
}

// Reinitialize app on user request
def changeHandler(evt) {
    log.debug "Reinitializing thermostat timer on user request, name: ${evt?.name}, value: ${evt?.value}, Description: ${evt?.descriptionText}"
    initialize()
}

// Reinitialize the current temperature and timers after a mode change, this is to workaround the issue of the last timer firing while in a non running mode, resume operations when supported modes are set
def modeChangeHandler(evt) {
    log.debug "Reinitializing thermostats on mode change notification, name: ${evt.name}, value: ${evt.value}"

    initialize()
}

// Handle events from contact sensors from doors/windows
def doorContactHandler(evt) {
    log.debug "Received door/window contact notification from ${evt.device.displayName}, name: ${evt.name}, value: ${evt.value}"
    
    if (evt.value == "open") { // When sensor is opened, disabled HVAC/appliances
        if (!atomicState.contactOpened || (atomicState.contactOpened + (doorOpenInterval * 60 * 1000) <= now())) { // // Don't overwrite if it hasn't been processed yet to ensure that earliest open is processed
            log.debug "Checking open contact sensors in ${(doorOpenInterval ?: 1) * 60} seconds"
            atomicState.contactOpened = now()
            def evtMap = [name:evt.name, value:evt.value, device:[id:evt.device.id, displayName:evt.device.displayName], descriptionText:evt.descriptionText, data:evt.data] // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442 so convert evt to a standard map and also we can't pass evt object to runIn
            runIn((doorOpenInterval ?: 1) * 60, doorContactCheck, [overwrite: true, data: evtMap]) // Schedule to check if it's still open, we need only
        } else {
            log.trace "Already set to check open contact sensor in ${(now() - atomicState.contactOpened + ((doorOpenInterval ?: 1) * 60 * 1000))/1000} seconds"
        }
    } else {
        log.debug "Checking closed contact sensors"
	    atomicState.contactOpened = 0 // Reset it so if it's opened immediately after it will reset the timer
        def evtMap = [name:evt.name, value:evt.value, device:[id:evt.device.id, displayName:evt.device.displayName], descriptionText:evt.descriptionText, data:evt.data] // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442 so convert evt to a standard map and also we can't pass evt object to runIn
        runIn(1, doorContactCheck, [overwrite: true, data: evtMap]) // Schedule to check if it's still open, we need only
    }
}

// Check if contacts are open/closed to change system operation
def doorContactCheck(evt) {
    log.debug "Checking door/window contact notification from ${evt.device.displayName}, name: ${evt.name}, value: ${evt.value}"

    def msg = ""
    if (openDoors.any { it.currentValue("contact") == "open" }) { // When any sensor is opened, disabled HVAC/appliances
        atomicState.openDoor = true // We have an open door
        msg = "${openDoors.find { it.currentValue("contact") == "open" }?.displayName} opened, turning off HVAC/applicances"
    } else if (atomicState.openDoor) { // If all sensors are closed from an earlier open, reset the the HVAC/appliances settings as per schedule
        atomicState.openDoor = false // Reset it
        msg = "All door/window sensors are closed, resuming HVAC/applicance operation"
    }

    if (msg) {
        log.info msg
		changeTemp(setSchedule(), !batterySaver) // Update HVAC/appliance state
        sendNotificationEvent(msg) // Do it in the end to avoid a timeout
    }
}

// Handle manual changes in thermostat setpoint for temporary Hold mode when using remote sensors
def thermostatSetTempHandler(evt) {
    log.debug "Recevied setpoint notification from ${evt.device.displayName}, name: ${evt.name}, value: ${evt.value}"

	// Check if we have a remote temperature sensor attached to this thermostat, if not we don't need to do anything
    def sch = setSchedule(false) // We don't need to set the schedule here
    def remoteTemperatureSensor
    if (customRemoteTempSensor) {
        remoteTemperatureSensor = settings."remoteTemperatureSensor${sch}"
    } else {
        remoteTemperatureSensor = settings."remoteTemperatureSensor"
    }

    // Lets see if the temperatue is different from the scheduled temperature and see if we are in hold more or not
    def coolingSetpoint = settings."tempCSetpoint${sch}" ?: 0
    def heatingSetpoint = settings."tempHSetpoint${sch}" ?: 0
    def locationScale = getTemperatureScale()
    def maxCTemp
    def minCTemp
    def maxHTemp
    def minHTemp
    if (locationScale == "C") {
        minCTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxCTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        minHTemp = MIN_HEAT_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxHTemp = MAX_HEAT_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Celsius, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
    } else {
        minCTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxCTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        minHTemp = MIN_HEAT_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
        maxHTemp = MAX_HEAT_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
        log.trace "Location is in Farenheit, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
    }

    // Check if the see temperature is any of the set heat/cold or mix/min settings, otherwise it's a manual adjustment and we should be in temporary hold mode
    if (!allowTempHold) {
        if (!(evt.name == "coolingSetpoint" ? (remoteTemperatureSensor ? [minCTemp, maxCTemp] : [coolingSetpoint]) : (remoteTemperatureSensor ? [minHTemp, maxHTemp] : [heatingSetpoint])).any { (it as Float) == (evt.value as Float) }) {
            def msg = "${app.label}: Temporary hold feature not enabled, ignoring ${evt.device.displayName} ${evt.name} override ${evt.value}°${remoteTemperatureSensor ? '. Using ' + remoteTemperatureSensor + ' remote temperature sensor' : ''}"
            atomicState."holdTemp${evt.device}" = false
            log.warn msg
            changeTemp(sch, false) // Reset setpoints, since we get this notification when setpoints change, don't force set them again to avoid a loop
            sendNotificationEvent(msg) // Do it in the end to avoid a timeout
        }
    } else if ((evt.name == "coolingSetpoint" ? (remoteTemperatureSensor ? [minCTemp, maxCTemp] : [coolingSetpoint]) : (remoteTemperatureSensor ? [minHTemp, maxHTemp] : [heatingSetpoint])).any { (it as Float) == (evt.value as Float) }) {
        log.trace "${remoteTemperatureSensor ? 'Found ' + remoteTemperatureSensor + ' remote temperature sensor connected to thermostat. ' : ''}Thermostat ${evt.device.displayName} set to predefined setpoint ${evt.value} for ${evt.name}, disabling temporary hold"
        atomicState."holdTemp${evt.device}" = false
    } else {
        log.info "${remoteTemperatureSensor ? 'Found ' + remoteTemperatureSensor + ' remote temperature sensor connected to thermostat. ' : ''}Thermostat ${evt.device.displayName} set to manual setpoint ${evt.value} for ${evt.name}, enabling temporary hold"
        atomicState."holdTemp${evt.device}" = true
    }
}

// Handle remote temp sensor and set temperature if using a remote sensor
def remoteChangeHandler(evt) {
    log.debug "Reinitializing thermostats on remote sensor temp change notification, name: ${evt?.name}, value: ${evt?.value}"

    changeTemp(setSchedule(false), !batterySaver) // We don't need to reschedule everytime the remote temp sensor changes
}

// This section sets the HVAC mode based outside temperature. HVAC fan mode is set to "auto".
def outsideTemperatureHandler(evt) {
    log.debug "Heat mode switch temperature $temperatureH, cool mode switch temperature $temperatureC"
    
    if (temperatureH == null || temperatureC == null) { // We are in Auto mode or user doesn't want us to switch modes
        return
    }

    def modeSwitched = false
    
    thermostats.each { thermostat ->
        def extTemp = outsideTemperatureSensor.currentTemperature
        log.debug "External temperature is: $extTemp"
        def thermostatState = thermostat.currentThermostatMode
        def thermostatFan = thermostat.currentThermostatFanMode
        log.debug "HVAC current mode $thermostatState"
        log.debug "HVAC Fan current mode $thermostatFan"
        if (extTemp < temperatureH) {
            if (thermostatState == "cool") {
                def hvacmode = "heat"
                thermostat.setThermostatMode(hvacmode)
                modeSwitched = true
                log.debug "HVAC mode set to $hvacmode"
            }
        } else if (extTemp > temperatureC) {
            if (thermostatState == "heat") {
                def hvacmode = "cool"
                thermostat.setThermostatMode(hvacmode)
                modeSwitched = true
                log.debug "HVAC mode set to $hvacmode"
            }
        }

        if (modeSwitched && thermostatFan != "auto") {
            thermostat.setThermostatFanMode("auto")
            log.debug "HVAC fan mode set to auto"
        }
    }
    
    if (modeSwitched) { // If we switched mode then reinitialize the app to set the setpoints
        initialize()
    }
}

// This function set the temperature and schedules the next change (if setTemp is false then it just sets the next schedule, i.e. kickStart timer)
def initialize(def setTemp = true) { // By default we change the temp and set the timer
    log.trace "Initialized with $settings, set temperature: $setTemp"

    def sch = setSchedule() // Set the next schedule timer
    if(setTemp) {
        // Reset hold status of all thermostats
        thermostats.each { thermostat ->
            log.trace "Resetting hold status of $thermostat"
            atomicState."holdTemp${thermostat}" = false
        }
        changeTemp(sch, !batterySaver)
    }
}

// Set the next schedule and return the schedule name, optionally disable setting the next schedule
private setSchedule(schedule = true) {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def calendar = Calendar.getInstance()
    calendar.setTimeZone(timeZone)
    def today = calendar.get(Calendar.DAY_OF_WEEK)
    def timeNow = now() + 60*1000 // Give it a buffer of 60 seconds ahead since the new Ticker scheduler randomizes the times slightly and just in case we get called earlier then scheduled time as it won't run again
    def midnightToday = timeToday("2000-01-01T23:59:59.999-0000", timeZone)
    log.trace("Set schedule: $schedule, Current time is ${(new Date(timeNow)).format("EEE MMM dd yyyy HH:mm z", timeZone)}, Midnight today is ${midnightToday.format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
              "\n" +
              (1..4).collect { "Weekday schedule${it} ${timeToday(settings."time${it}", timeZone).format("HH:mm z", timeZone)}" }?.join("\n") +
              "\n" +
              (1..4).collect { "Weekend schedule${it} ${timeToday(settings."time${it}1", timeZone).format("HH:mm z", timeZone)}" }?.join("\n"))

    // This section is where the time/temperature schedule is set
    switch (today) {
        case Calendar.MONDAY:
        	if (timeNow >= (midnightToday - 1).time && timeNow < timeToday(time1, timeZone).time) { // Are we between midnight Sunday and 1st time Monday, schedule Monday 1st time, return Sunday 4th time
                if (schedule) nextRun(timeToday(time1, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 14
            } else if (timeNow >= timeToday(time1, timeZone).time && timeNow < timeToday(time2, timeZone).time) { // Are we between 1st time and 2nd time
                if (schedule) nextRun(timeToday(time2, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time2, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time2, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 1
            } else if (timeNow >= timeToday(time2, timeZone).time && timeNow < timeToday(time3, timeZone).time) { // Are we between 2nd time and 3rd time
                if (schedule) nextRun(timeToday(time3, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time3, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time3, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 2
            } else if (timeNow >= timeToday(time3, timeZone).time && timeNow < timeToday(time4, timeZone).time) { // Are we between 3rd time and 4th time
                if (schedule) nextRun(timeToday(time4, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time4, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time4, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 3
            } else if (timeNow >= timeToday(time4, timeZone).time && timeNow < midnightToday.time) { // Are we between 4th time and midnight, schedule next day
                if (schedule) nextRun(timeToday(time1, timeZone) + 1, initialize)
                log.info("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 4
            }
            break

        case Calendar.TUESDAY:
        case Calendar.WEDNESDAY:
        case Calendar.THURSDAY:
        case Calendar.FRIDAY:
            if (timeNow >= (midnightToday - 1).time && timeNow < timeToday(time1, timeZone).time) { // Are we between midnight yesterday and 1st time today, schedule today 1st time, return yesterday 4th time
                if (schedule) nextRun(timeToday(time1, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 4
            } else if (timeNow >= timeToday(time1, timeZone).time && timeNow < timeToday(time2, timeZone).time) { // Are we between 1st time and 2nd time
                if (schedule) nextRun(timeToday(time2, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time2, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time2, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 1
            } else if (timeNow >= timeToday(time2, timeZone).time && timeNow < timeToday(time3, timeZone).time) { // Are we between 2nd time and 3rd time
                if (schedule) nextRun(timeToday(time3, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time3, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time3, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 2
            } else if (timeNow >= timeToday(time3, timeZone).time && timeNow < timeToday(time4, timeZone).time) { // Are we between 3rd time and 4th time
                if (schedule) nextRun(timeToday(time4, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time4, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time4, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 3
            } else if (timeNow >= timeToday(time4, timeZone).time && timeNow < midnightToday.time) { // Are we between 4th time and midnight, schedule next day
                if (schedule) nextRun(timeToday(time1, timeZone) + 1, initialize)
                log.info("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 4
            }
            break

        case Calendar.SATURDAY:
        	if (timeNow >= (midnightToday - 1).time && timeNow < timeToday(time11, timeZone).time) { // Are we between midnight Friday and 1st time Saturday, schedule Saturday 1st time, return Friday 4th time
                if (schedule) nextRun(timeToday(time11, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time11, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time11, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 4
            } else if (timeNow >= timeToday(time11, timeZone).time && timeNow < timeToday(time21, timeZone).time) { // Are we between 1st time and 2nd time
                if (schedule) nextRun(timeToday(time21, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time21, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time21, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 11
            } else if (timeNow >= timeToday(time21, timeZone).time && timeNow < timeToday(time31, timeZone).time) { // Are we between 2nd time and 3rd time
                if (schedule) nextRun(timeToday(time31, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time31, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time31, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 12
            } else if (timeNow >= timeToday(time31, timeZone).time && timeNow < timeToday(time41, timeZone).time) { // Are we between 3rd time and 4th time
                if (schedule) nextRun(timeToday(time41, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time41, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time41, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 13
            } else if (timeNow >= timeToday(time41, timeZone).time && timeNow < midnightToday.time) { // Are we between 4th time Saturday and midnight Saturday, schedule Sunday, return Saturday
                if (schedule) nextRun(timeToday(time11, timeZone) + 1, initialize)
                log.info("Scheduled next adjustment for ${(timeToday(time11, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${(timeToday(time11, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 14
            }
            break

        case Calendar.SUNDAY:
        	if (timeNow >= (midnightToday - 1).time && timeNow < timeToday(time1, timeZone).time) { // Are we between midnight Saturday and 1st time on Sunday, schedule Sunday 1st time, return Saturday 4th time
                if (schedule) nextRun(timeToday(time21, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time1, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 14
            } else if (timeNow >= timeToday(time11, timeZone).time && timeNow < timeToday(time21, timeZone).time) { // Are we between 1st time and 2nd time
                if (schedule) nextRun(timeToday(time21, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time21, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time21, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 11
            } else if (timeNow >= timeToday(time21, timeZone).time && timeNow < timeToday(time31, timeZone).time) { // Are we between 2nd time and 3rd time
                if (schedule) nextRun(timeToday(time31, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time31, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time31, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 12
            } else if (timeNow >= timeToday(time31, timeZone).time && timeNow < timeToday(time41, timeZone).time) { // Are we between 3rd time and 4th time
                if (schedule) nextRun(timeToday(time41, timeZone), initialize)
                log.info("Scheduled next adjustment for ${timeToday(time41, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${timeToday(time41, timeZone).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 13
            } else if (timeNow >= timeToday(time41, timeZone).time && timeNow < midnightToday.time) { // Are we between 4th time Sunday and midnight Sunday, we schedule Monday 1st time, return Sunday 4th time
                if (schedule) nextRun(timeToday(time1, timeZone) + 1, initialize)
                log.info("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                //sendNotificationEvent("Scheduled next adjustment for ${(timeToday(time1, timeZone) + 1).format("EEE MMM dd yyyy HH:mm z", timeZone)}")
                return 14
            }
            break
            
        default:
        	log.error "Unknown Day of Week: $today"
            break
    }
}

// This section is where the thermostat temperature settings are set. 
private void changeTemp(sch, forceSet = false) {
    def openDoor = atomicState.openDoor // Do we have an open door/window?

    def msg = ""
    
    if (coolers || heaters) { // HEATING/COOLING APPLIANCES
        def coolingSetpoint = settings."tempCSetpoint${sch}" ?: 0
        def heatingSetpoint = settings."tempHSetpoint${sch}" ?: 0
        def remoteTemperatureSensor

        if (customRemoteTempSensor) {
            remoteTemperatureSensor = settings."remoteTemperatureSensor${sch}"
        } else {
            remoteTemperatureSensor = settings."remoteTemperatureSensor"
        }

        log.trace "Heating/Cooling appliance mode: Target Heat: $heatingSetpoint°, Target Cool: $coolingSetpoint°, Remote Temp Sensor(s): $remoteTemperatureSensor, Force set: $forceSet"

        // Check for invalid configuration
        if (coolingSetpoint && (heatingSetpoint >= coolingSetpoint)) {
            msg = "INVALID CONFIGURATION: Target Heat temperature: $heatingSetpoint° must be LESS than Target Cool temperature: $coolingSetpoint°\nNot changing settings on appliances, correct the SmartApp settings"
            log.error msg
            sendPush(msg)
            return
        }

        def currentTemp = (remoteTemperatureSensor*.currentTemperature).sum()/(remoteTemperatureSensor*.currentTemperature).count { it } // Take the average temp of the remote temperature sensor(s) (manage transition from legacy code to new code)
        log.trace("Remote Sensor(s) Current Temp (Average): $currentTemp°, Swing Threshold: $threshold")

        // Order is important, Shutdown, Cooling, Heating and last Turn Off
        if (openDoor) { // Check if we need to shutdown
            coolers.each { cooler ->
                if (forceSet || cooler.currentValue("switch") != "off") {
                    cooler.off()
                    msg = "Open sensor: Turning Cooling appliance $cooler OFF"
                }
            }
            heaters.each { heater ->
                if (forceSet || heater.currentValue("switch") != "off") {
                    heater.off()
                    msg = "Open sensor: Turning Heating appliance $heater OFF"
                }
            }
        } else if (coolingSetpoint && ((currentTemp - coolingSetpoint) > threshold)) { // Turn cool on first
            coolers.each { cooler ->
                if (forceSet || cooler.currentValue("switch") != "on") {
                    cooler.on()
                    msg = "Turning Cooling appliance $cooler ON, Target: $coolingSetpoint°"
                }
            }
            heaters.each { heater ->
                if (forceSet || heater.currentValue("switch") != "off") {
                    heater.off()
                    msg = "Turning Heating appliance $heater OFF"
                }
            }
        } else if (heatingSetpoint && ((heatingSetpoint - currentTemp) > threshold)) { // Heating second (order is important to avoid constant switching)
            coolers.each { cooler ->
                if (forceSet || cooler.currentValue("switch") != "off") {
                    cooler.off()
                    msg = "Turning Cooling appliance $cooler OFF"
                }
            }
            heaters.each { heater ->
                if (forceSet || heater.currentValue("switch") != "on") {
                    heater.on()
                    msg = "Turning Heating appliance $heater ON, Target: $heatingSetpoint°"
                }
            }
        } else if ((coolingSetpoint && ((coolingSetpoint - currentTemp) > threshold)) || (heatingSetpoint && ((currentTemp - heatingSetpoint) > threshold))) { // Turn off - don't check valid mode
            coolers.each { cooler ->
                if (forceSet || cooler.currentValue("switch") != "off") {
                    cooler.off()
                    msg = "Turning Cooling appliance $cooler OFF"
                }
            }
            heaters.each { heater ->
                if (forceSet || heater.currentValue("switch") != "off") {
                    heater.off()
                    msg = "Turning Heating appliance $heater OFF"
                }
            }
        } else if (!coolingSetpoint && !heatingSetpoint) {
            log.trace "No heating or cooling setpoints defined, skipping appliance adjustments"
        } else if (!heatingSetpoint) {
            log.trace "No heating setpoint defined, skipping appliance adjustments"
        } else if (!coolingSetpoint) {
            log.trace "No cooling setpoint defined, skipping appliance adjustments"
        }
    } else { // THERMOSTATS
        thermostats.each { thermostat ->
            def fanMode = settings."fanMode${sch}"
            def coolingSetpoint = settings."tempCSetpoint${sch}" ?: 0
            def heatingSetpoint = settings."tempHSetpoint${sch}" ?: 0
            def thermostatState = thermostat.currentThermostatMode
            def thermostatCurrentHeating = thermostat.currentValue("heatingSetpoint")
            def thermostatCurrentCooling = thermostat.currentValue("coolingSetpoint")
            def remoteTemperatureSensor

            if (customRemoteTempSensor) {
                remoteTemperatureSensor = settings."remoteTemperatureSensor${sch}"
            } else {
                remoteTemperatureSensor = settings."remoteTemperatureSensor"
            }

            log.trace "Thermostat mode: $thermostatState, Current Heating: $thermostatCurrentHeating°, Target Heat: $heatingSetpoint°, Current Cooling: $thermostatCurrentCooling°, Target Cool: $coolingSetpoint°, Remote Temp Sensor(s): $remoteTemperatureSensor, Schedule: $sch, Force set: $forceSet"

            // Check for invalid configuration
            if ((thermostatState == "auto") && (coolingSetpoint && (heatingSetpoint >= coolingSetpoint))) {
                msg = "INVALID CONFIGURATION: Target Heat temperature: $heatingSetpoint° must be LESS than Target Cool temperature: $coolingSetpoint°\nNot changing settings on appliances, correct the SmartApp settings"
                log.error msg
                sendPush(msg)
                return
            }

            // If thermostat is on temporary hold and ignore it (except if we have an open door/window)
            if (openDoor) { // On an open door/window we reset temp holds to return to the last programmed setting
                atomicState."holdTemp${thermostat}" = false
                log.trace "Open door/window, resetting hold status of $thermostat"
            } else if (atomicState."holdTemp${thermostat}") { // If we are on hold temp mode then ignore temperature changes since user has put it on hold mode
                log.info "Thermostat ${thermostat} is in hold temperature mode, not making any changes to thermostat based on remote temp sensor"
                return
            }

            def locationScale = getTemperatureScale()
            def maxCTemp
            def minCTemp
            def maxHTemp
            def minHTemp
            if (locationScale == "C") {
                minCTemp = MIN_COOL_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
                maxCTemp = MAX_COOL_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
                minHTemp = MIN_HEAT_TEMP_C // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
                maxHTemp = MAX_HEAT_TEMP_C // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
                log.trace "Location is in Celsius, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
            } else {
                minCTemp = MIN_COOL_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
                maxCTemp = MAX_COOL_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
                minHTemp = MIN_HEAT_TEMP_F // minimum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to minimum)
                maxHTemp = MAX_HEAT_TEMP_F // maximum temperature (thermostat could be in a different room at different temp or not updated very often so inaccurate hence to set to maximum)
                log.trace "Location is in Farenheit, MaxHeatTemp $maxHTemp, MinHeatTemp $minHTemp, MaxCoolTemp $maxCTemp, MinCoolTemp $minCTemp for thermostat"
            }

            if (remoteTemperatureSensor) { // Remote temperature sensor
                def currentTemp = (remoteTemperatureSensor*.currentTemperature).sum()/(remoteTemperatureSensor*.currentTemperature).count { it } // Take the average temp of the remote temperature sensor(s) (manage transition from legacy code to new code)
                log.trace("Remote Sensor(s) Current Temp (Average): $currentTemp°, Swing Threshold: $threshold")

                if (thermostatState == "auto") {
                    // Order is important, Shutdown, Cooling, Heating and last Turn Off
                    if (openDoor) { // Check if we need to shutdown
                        if (forceSet || thermostatCurrentCooling != maxCTemp) {
                            thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                            msg = "Open sensor: $thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                        }
                        if (forceSet || thermostatCurrentHeating != minHTemp) {
                            thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                            msg = "Open sensor: $thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                        }
                    } else if (coolingSetpoint && ((currentTemp - coolingSetpoint) > threshold)) { // Turn cool on first
                        if (forceSet || thermostatCurrentCooling != minCTemp) {
                            thermostat.setCoolingSetpoint(minCTemp) // Set to cool
                            msg = "$thermostat Cooling ON, Thermostat Cool: ${minCTemp}, Target: $coolingSetpoint°"
                        }
                        if (forceSet || thermostatCurrentHeating != minHTemp) {
                            thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                            msg = "$thermostat Cooling ON, Thermostat Cool: ${minCTemp}, Target: $coolingSetpoint°"
                        }
                    } else if (heatingSetpoint && ((heatingSetpoint - currentTemp) > threshold)) { // Heating second (order is important to avoid constant switching)
                        if (forceSet || thermostatCurrentHeating != maxHTemp) {
                            thermostat.setHeatingSetpoint(maxHTemp) // Set to heat
                            msg = "$thermostat Heating ON, Thermostat Heat: ${maxHTemp}, Target: $heatingSetpoint°"
                        }
                        if (forceSet || thermostatCurrentCooling != maxCTemp) {
                            thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                            msg = "$thermostat Heating ON, Thermostat Heat: ${maxHTemp}, Target: $heatingSetpoint°"
                        }
                    } else if ((coolingSetpoint && ((coolingSetpoint - currentTemp) > threshold)) || (heatingSetpoint && ((currentTemp - heatingSetpoint) > threshold))) { // Turn off - don't check valid mode
                        if (forceSet || thermostatCurrentCooling != maxCTemp) {
                            thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                            msg = "$thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                        }
                        if (forceSet || thermostatCurrentHeating != minHTemp) {
                            thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                            msg = "$thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                        }
                    } else if (!coolingSetpoint && !heatingSetpoint) {
                        log.trace "No heating or cooling setpoints defined, skipping $thermostat adjustments"
                    } else if (!heatingSetpoint) {
                        log.trace "No heating setpoint defined, skipping $thermostat adjustments"
                    } else if (!coolingSetpoint) {
                        log.trace "No cooling setpoint defined, skipping $thermostat adjustments"
                    }
                } else if (thermostatState == "cool") { // air conditioner
                    // Order is important, Shutdown, Cooling, Heating and last Turn Off
                    if (openDoor) { // Check if we need to shutdown
                        if (forceSet || thermostatCurrentCooling != maxCTemp) {
                            thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                            msg = "Open sensor: $thermostat Cooling OFF, Thermostat Cool: ${maxCTemp}"
                        }
                    } else if (coolingSetpoint && ((currentTemp - coolingSetpoint) > threshold)) { // Turn cool on
                        if (forceSet || thermostatCurrentCooling != minCTemp) {
                            thermostat.setCoolingSetpoint(minCTemp) // Set to cool
                            msg = "$thermostat Cooling ON, Thermostat Cool: ${minCTemp}, Target: $coolingSetpoint°"
                        }
                    } else if (coolingSetpoint && ((coolingSetpoint - currentTemp) > threshold)) { // Turn cool off - don't check valid mode
                        if (forceSet || thermostatCurrentCooling != maxCTemp) {
                            thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                            msg = "$thermostat Cooling OFF, Thermostat Cool: ${maxCTemp}"
                        }
                    } else if (!coolingSetpoint) {
                        log.trace "$thermostat no cooling setpoint defined, skipping adjustments"
                    }
                } else { // Heater or emergency heater
                    // Order is important, Shutdown, Cooling, Heating and last Turn Off
                    if (openDoor) { // Check if we need to shutdown
                        if (forceSet || thermostatCurrentHeating != minHTemp) {
                            thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                            msg = "Open sensor: $thermostat Heating OFF, Thermostat Heat: ${minHTemp}"
                        }
                    } else if (heatingSetpoint && ((heatingSetpoint - currentTemp) > threshold)) {
                        if (forceSet || thermostatCurrentHeating != maxHTemp) {
                            thermostat.setHeatingSetpoint(maxHTemp) // Set to heat
                            msg = "$thermostat Heating ON, Thermostat Heat: ${maxHTemp}, Target: $heatingSetpoint°"
                        }
                    } else if (heatingSetpoint && ((currentTemp - heatingSetpoint) > threshold)) { // Disable heat - don't check valid mode
                        if (forceSet || thermostatCurrentHeating != minHTemp) {
                            thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                            msg = "$thermostat Heating OFF, Thermostat Heat: ${minHTemp}"
                        }
                    } else if (!heatingSetpoint) {
                        log.trace "$thermostat no heating setpoint defined, skipping adjustments"
                    }
                }
            } else { // Local thermostat
                // Order is important, Shutdown, Cooling, Heating and last Turn Off
                if (openDoor) { // Check if we need to shutdown
                    switch (thermostatState) {
                        case "auto":
                            if (forceSet || thermostatCurrentCooling != maxCTemp) {
                                thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                                msg = "Open sensor turning $thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                            }
                            if (forceSet || thermostatCurrentHeating != minHTemp) {
                                thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                                msg = "Open sensor turning $thermostat OFF, Thermostat Cool: ${maxCTemp}, Thermostat Heat: ${minHTemp}"
                            }
                            break
                            
                        case "cool":
                            if (forceSet || thermostatCurrentCooling != maxCTemp) {
                                thermostat.setCoolingSetpoint(maxCTemp) // Disable cool
                                msg = "Open sensor turning $thermostat OFF, Thermostat Cool: ${maxCTemp}"
                            }
                            break
                            
                        case "heat":
                            if (forceSet || thermostatCurrentHeating != minHTemp) {
                                thermostat.setHeatingSetpoint(minHTemp) // Disable heat
                                msg = "Open sensor turning $thermostat OFF, Thermostat Heat: ${minHTemp}"
                            }
                            break
                            
                        default:
                            break
                    }
                } else if (thermostatState == "auto") {
                    if (heatingSetpoint && (forceSet || (thermostatCurrentHeating != heatingSetpoint))) {
                        thermostat.setHeatingSetpoint(heatingSetpoint)
                        msg += "Set $thermostat Heat ${heatingSetpoint}°"
                    }
                    if (coolingSetpoint && (forceSet || (thermostatCurrentCooling != coolingSetpoint))) {
                        thermostat.setCoolingSetpoint(coolingSetpoint)
                        if (msg) {
                            msg += ", Cool ${coolingSetpoint}°"
                        } else {
                            msg += "Set $thermostat Cool ${coolingSetpoint}°"
                        }
                    }
                    
                    if (!coolingSetpoint && !heatingSetpoint) {
                        log.trace "No heating or cooling setpoints defined, skipping $thermostat adjustment"
                    }
                } else if (thermostatState == "cool") {
                    if (coolingSetpoint && (forceSet || (thermostatCurrentCooling != coolingSetpoint))) {
                        thermostat.setCoolingSetpoint(coolingSetpoint)
                        msg = "Set $thermostat Cool ${coolingSetpoint}°"
                    } else if (!coolingSetpoint) {
                        log.trace "$thermostat no cooling setpoint defined, skipping adjustment"
                    }
                } else { // heater or emergency heater
                    if (heatingSetpoint && (forceSet || (thermostatCurrentHeating != heatingSetpoint))) {
                        thermostat.setHeatingSetpoint(heatingSetpoint)
                        msg = "Set $thermostat Heat ${heatingSetpoint}°"
                    } else if (!heatingSetpoint) {
                        log.trace "$thermostat no heating setpoint defined, skipping adjustment"
                    }
                }
            }

            // Set fan mode
            if (fanMode) {
                setFanMode(thermostat, fanMode)
            } else {
                log.trace "No fan mode selected skipping setting fan mode"
            }
        }
    }

    if (msg) {
        log.info msg
    }
}

private setFanMode(thermostat, fanMode, forceSet = false) {
    def fanState = thermostat.currentThermostatFanMode
    log.trace "$thermostat Fan state: $fanState, Target fan mode: $fanMode, Force set: $forceSet"
    
    switch (fanMode) {
        case "Auto":
        	if (forceSet || fanState != "auto") {
                thermostat.setThermostatFanMode("auto")
                log.info "Setting $thermostat fan mode to Auto"
            }
            break
            
        case "On":
        	if (forceSet || fanState != "on") {
                thermostat.setThermostatFanMode("on")
                log.info "Setting $thermostat fan mode to On"
            }
        	break
            
        case "Circulate":
        	if (forceSet || fanState != "circulate") {
                thermostat.setThermostatFanMode("circulate")
                log.info "Setting $thermostat fan mode to Circulate"
            }
        	break
            
        default:
            log.error "Invalid fan mode selected: $fanMode"
        	break
    }
}

private nextRun(dateTime, handler) {
    schedule(dateTime, handler) // Use schedule instead of runOnce since the scheduler sometimes drops runOnce and wont' pick it up, schedule will be picked up again
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "5-2 Day Thermostat",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt = null) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "5-2 Day Thermostat with Remote Sensor"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = 
                [ thermostats,
                 coolers.
                 heater,
                 openDoors,
                 remoteTempertureSensor1,
                 remoteTempertureSensor2,
                 remoteTempertureSensor3,
                 remoteTempertureSensor4,
                 remoteTempertureSensor11,
                 remoteTempertureSensor12,
                 remoteTempertureSensor13,
                 remoteTempertureSensor14,
                 outsideTemperatureSensor ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}


// THIS IS THE END OF THE FILE